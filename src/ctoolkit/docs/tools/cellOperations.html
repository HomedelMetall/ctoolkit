<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ctoolkit.tools.cellOperations API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ctoolkit.tools.cellOperations</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from toolkit.global_vars.ext_libs import *

class cellOperations:
    def __init__(self):
        pass

    @calculate_time
    def func3(self):
        time.sleep(3)   

    @calculate_time
    def frac_to_cart(self, B, atom_set):
        new_atom_set = np.dot(B, atom_set.T).T
        
        return new_atom_set

    @calculate_time
    def cart_to_frac(self, B, atom_set):
        Binv = np.linalg.inv(B)
        new_atom_set = np.dot(Binv, atom_set.T).T

        return new_atom_set

    def rigid_displacement(self, vector, structure):
        new_cart = np.zeros([len(structure.at_cart), 3], dtype=float)
        new_frac = np.zeros([len(structure.at_frac), 3], dtype=float)
        vector = np.array(vector, dtype=float)

        disp = np.zeros([3], dtype=float)
        for i in range(3):
            disp += vector[i]*structure.B[i,:]

        for atom in range(len(structure.at_cart)):
            new_cart[atom] = np.copy(structure.at_cart[atom] + disp)
            
        structure.at_cart = np.copy(new_cart)
        structure.recalculate_poscar()

    def apply_rotation(self, vector, angle, axis, origin=None):
        # The idea: 
        # We want to rotate a group of atoms. The positions
        # of the atoms are given as vectors from the crystallographic
        # origin of coordinates. Thus what we want to do is:
        #   move origin -&gt; apply rotation along given axis -&gt; go back to crystal. origin

        # We use the tensorial form of the rotation operator
        axis = np.array(axis)
        axis = axis/(np.sqrt(np.dot(axis, axis)))
        cross = np.zeros([3,3], dtype=float)
        cart = np.array([[1.0, .0, .0], [.0, 1.0, .0], [.0, .0, 1.0]], dtype=float)
        for i in range(3):
            c1 = np.cross(axis, cart[i])
            cross += np.outer(c1, cart[i])
        R = np.cos(angle)*np.eye(3,3) + (np.sin(angle))*(cross) + (1-np.cos(angle))*(np.outer(axis, axis))

        # Now we move the origin, compute, and go back to the crystal. origin. All packed.
        if origin is None:
            origin = np.zeros([3], dtype=float)
        
        return np.dot(R, vector - origin) + origin
        
    def rigid_rotation(self, vector_list, angle, axis, origin=None):
        if len(vector_list.shape) &lt; 2:
            return self.apply_rotation(vector_list, angle, axis, origin)
        else:
            veclist = []
            for i in range(len(vector_list)):
                veclist.append(self.apply_rotation(vector_list[i], angle, axis, origin))
            return np.array(veclist, dtype=float)

    def new_supercell_VASP(self, N, VASP_struct):
        new_VASP = self.copy_structure(VASP_struct)
        # Objects can be different...

        new_structure = new_VASP.POSCAR
        new_structure.at_frac = np.zeros([np.prod(N)*len(VASP_struct.POSCAR.at_frac), 3])
        ct_atom = 0
        ct2 = 0
        new_structure.namelist = [&#39;&#39;]
        new_structure.atom_id =  []
        for specie_id, specie in enumerate(VASP_struct.POSCAR.names):
            new_structure.multiplicity[specie_id] = VASP_struct.POSCAR.multiplicity[specie_id]*np.prod(N)
            for atom in range(VASP_struct.POSCAR.multiplicity[specie_id]):
            #for nx, ny, nz in [(nx, ny, nz) for nx in range(N[0]) for ny in range(N[1]) for nz in range(N[2])]:
                #for atom in range(structure.multiplicity[specie_id]):
                for nx, ny, nz in [(nx, ny, nz) for nx in range(N[0]) for ny in range(N[1]) for nz in range(N[2])]: #This inverts how the atoms are printed
                    Id = np.eye(3)
                    cell_vector = nx*Id[0] + ny*Id[1] + nz*Id[2]

                    # Frac coordinates need to be reescaled to the new supercell
                    temp_vec = np.copy(VASP_struct.POSCAR.at_frac[ct2] + cell_vector)
                    for i in range(3):
                        new_structure.at_frac[ct_atom, i] = temp_vec[i]/N[i]
                    new_structure.namelist.append(VASP_struct.POSCAR.namelist[ct2])
                    new_structure.atom_id.append(VASP_struct.POSCAR.atom_id[ct2])
                    ct_atom += 1
                ct2 += 1

        for i in range(3):
            new_structure.B[i] = np.copy(VASP_struct.POSCAR.B[i]*N[i])

        new_structure.at_cart = np.copy(self.frac_to_cart(new_structure.B, new_structure.at_frac))

        mult = float(len(VASP_struct.POSCAR.at_frac))/float(len(new_structure.at_frac))
        new_structure.volume *= mult
        #new_structure.energy *= mult

        return new_structure

    def new_supercell(self, N, structure):
        # We select and divide into smaller functions as a sort of override
        if structure.type == &#39;VASP&#39;:
            new_structure = self.new_supercell_VASP(N, structure)

        return new_structure

    # Add atoms given a vector
    def spawn_cell_frac(self, vector, structure):
        new_frac = np.copy(structure.at_frac)
        for i in range(len(new_frac)):
            new_frac[i] = structure.at_frac[i] + np.array(vector, dtype=float)

        return np.copy(new_frac)

    def spawn_cell_invfrac(self, vector, structure):
        new_frac = np.copy(structure.at_frac)
        tol = 0.02
        for i in range(len(new_frac)):
            &#34;&#34;&#34;
            temp_vec = -structure.at_frac[i] + np.array([1,1,1], dtype=float)
            # Correct frac on the fly
            for i in range(3):
                if(np.abs(temp_vec[i]-1.0) &lt; tol):
                    temp_vec[i] -= 0.0#1.0

            #new_frac[i] = temp_vec + np.array(vector, dtype=float)
            &#34;&#34;&#34;

            # We go to [-1,-1,-1] and then invert!
            temp_vec = -(structure.at_frac[i] + np.array([-1,-1,-1], dtype=float))
            # Correct frac on the fly
            for j in range(3):
                if(np.abs(temp_vec[j]-1.0) &lt; tol):
                    temp_vec[j] -= 1.0

            new_frac[i] = temp_vec + np.array(vector, dtype=float)
            #new_frac[i] = np.array(vector, dtype=float)-structure.at_frac[i] + np.array([-1,-1,-1], dtype=float)

        return np.copy(new_frac)

    def centrosymmetric_supercell_VASP(self, VASP_structure):
        new_VASP = self.copy_structure(VASP_structure)
        new_structure = new_VASP.POSCAR

        # Centrosymmetry requires an atom well located for the origin.
        # Thus we need to shift to set the zero (for now experimental)
        shifted_structure = self.copy_structure(structure).POSCAR
        for i in range(len(shifted_structure.at_frac)):
            shifted_structure.at_frac[i] -= structure.at_frac[0]

        cells = []
        &#34;&#34;&#34;
        for i, j in [(i,j) for i in range(2) for j in range(2)]:
            cells.append(self.spawn_cell_frac([i,j,0], shifted_structure))
        for i, j in [(i,j) for i in range(2) for j in range(2)]:
            cells.append(self.spawn_cell_invfrac([i,j,1], shifted_structure))
        &#34;&#34;&#34;
        # Test: only 2 cells
        cells.append(self.spawn_cell_frac([0,0,0], shifted_structure))
        cells.append(self.spawn_cell_invfrac([0,0,1], shifted_structure))
        N = [1,1,2]
        ct = 0
        ct2 = 0
        new_structure.at_frac = np.zeros([np.prod(N)*len(structure.at_frac), 3])
        new_structure.namelist = [&#39;&#39;]
        new_structure.atom_id = []
        for specie_id, specie in enumerate(structure.names):
            new_structure.multiplicity[specie_id] = structure.multiplicity[specie_id]*np.prod(N)
            for atom in range(structure.multiplicity[specie_id]):
                for cell in cells:
                    # Frac coordinates need to be reescaled to the new supercell
                    temp_vec = np.copy(cell[ct2])
                    for i in range(3):
                        new_structure.at_frac[ct, i] = temp_vec[i]/N[i]
                    new_structure.atom_id.append(structure.atom_id[ct2])
                    new_structure.namelist.append(structure.namelist[ct2])
                    ct += 1
                ct2 += 1

        for i in range(3):
            new_structure.B[i] = np.copy(structure.B[i]*N[i])

        new_structure.at_cart = np.copy(self.frac_to_cart(new_structure.B, new_structure.at_frac))

        mult = float(len(VASP_struct.POSCAR.at_frac))/float(len(new_structure.at_frac))
        new_structure.volume *= mult
        new_structure.energy *= mult

        return new_structure

    def centrosymmetric_supercell(self, structure):
        # We select and divide into smaller functions as a sort of override
        if structure.type == &#39;VASP&#39;:
            new_structure = self.new_supercell_VASP(N, structure)

        return new_structure

    def interpolate_structures_VASP(self, struct1, struct2, num_images):
        structures = []
        structures.append(struct1)
        for i in range(1, num_images+1):
            # Load structure + cleanup of frac coordinates
            new_VASP = self.copy_structure(struct1)
            new_structure = new_VASP.POSCAR
            new_structure.frac_image_sniper()
            # Linear interpolation of cell &amp; frac &amp; cart

            new_structure.B = struct1.POSCAR.B + float(i)/(num_images+2)*(struct2.POSCAR.B-struct1.POSCAR.B)
            new_structure.at_frac = struct1.POSCAR.at_frac + float(i)/(num_images+2)*(struct2.POSCAR.at_frac-struct1.POSCAR.at_frac)
            # Could put a control for running images here
            new_structure.at_cart = self.frac_to_cart(new_structure.B, new_structure.at_frac)#struct1.at_cart + float(i/(num_images+2))*(struct2.at_cart-struct1.at_cart)
            # Probably useless or troublesome:
            new_structure.frac_image_sniper()
            structures.append(new_VASP)

        structures.append(struct2)

        return structures

    def interpolate_structures(self, struct1, struct2, num_images):
        # We select and divide into smaller functions as a sort of override
        if struct1.type != struct2.type:
            print(&#39;Error! Structures in different format. Transform them first!&#39;)
            sys.exit()
            # Attempt conversion
            #print(&#39;Attempting to unify types...&#39;)
            #struct1 = self.transform_type(struct1, struct2.type)
            #print(&#34;Successfully transformed type of structure 1 (%s) into %s!&#34; % (struct1.type, struct2.type))

        if struct1.type == &#39;VASP&#39;:
           structures = self.interpolate_structures_VASP(struct1, struct2, num_images)

        return structures

    @calculate_time
    def find_firstneighbors(self, atom, satellites, basis):
        d = np.zeros([len(satellites)], dtype=float)
        tol = 20 # in percentage
        for i in range(len(satellites)):
            best_transform, transform_key = self.findBestPairPeriodic(atom, satellites[i], basis)
            dist = np.sqrt(np.dot(atom-best_transform, atom-best_transform))
            # We exclude the &#34;self&#34; atom
            if(dist &gt; 0.0):
                d[i] = dist
            else:
                d[i] = 1E5
        #print(np.sort(d)) 
        min_dist = np.min(d)
        list_neighbors = []
        for i in range(len(satellites)):
            if d[i] &lt; min_dist*(1+tol/100):
                #print(i, d[i], min_dist*(1+tol/100))
                list_neighbors.append(i)

        return list_neighbors

    def find_full_molecules(self, struct, center, satellite, num_neighbors=0):
        center_atoms = struct.filter_atoms(center)
        sat_atoms = struct.filter_atoms(satellite)
        all_atoms = np.copy(struct.at_cart)

        center_atoms_list = struct.filter_atoms_list(center)
        sat_atoms_list = struct.filter_atoms_list(satellite)

        groups = []
        nice_molecules = []
        for i in range(len(center_atoms)):
            nice_molecule = []
            sat_atom_neighbors = []
            list_neighbors = self.find_firstneighbors(center_atoms[i], sat_atoms, struct.B)

            for j in list_neighbors:
                sat_atom_neighbors.append(sat_atoms_list[j])

            if num_neighbors==1:
                # center atom new first neighbors
                cfn_bulk = self.find_firstneighbors(center_atoms[i], all_atoms, struct.B)
                cfn_list = []
                for cfn in cfn_bulk:
                    if ((cfn not in center_atoms_list) and
                        (cfn not in sat_atom_neighbors)):
                        cfn_list.append(cfn)

                # find the first neighbors of every satellite
                sfn_list_col = []
                for j in sat_atom_neighbors:
                    sfn_bulk = self.find_firstneighbors(struct.at_cart[j], all_atoms, struct.B)
                    sfn_list = []
                    for sfn in sfn_bulk:
                        if ((sfn not in center_atoms_list) and 
                            (sfn not in sat_atom_neighbors) and
                            (sfn not in cfn_list)): 
                            sfn_list.append(sfn)

                    sfn_list_col.append(sfn_list)
                 
                groups.append([center_atoms_list[i], sat_atom_neighbors, cfn_list, sfn_list_col])
                nice_molecule.append(center_atoms_list[i])
                for sat in sat_atom_neighbors: nice_molecule.append(sat)
                for cfn in cfn_list: nice_molecule.append(cfn)
                for sfn in sfn_list: nice_molecule.append(sfn)
                nice_molecules.append(nice_molecule)
            else:
                groups.append([center_atoms_list[i], sat_atom_neighbors])

            sys.stdout.write(&#34;%3.3f%%\r&#34; % (100*(i+1)/len(center_atoms)))
            sys.stdout.flush()

        return groups, nice_molecules

    # Find groups of atoms between the CENTER
    # of the interaction and the SATELLITE possible
    # atoms belonging to a particular species
    @calculate_time
    def find_groups(self, struct, center, satellite, excludeSatList=[]):
        center_atoms = struct.filter_atoms(center)
        sat_atoms = struct.filter_atoms(satellite, excludeSatList=excludeSatList)
        center_atoms_list = struct.filter_atoms_list(center)
        sat_atoms_list = struct.filter_atoms_list(satellite, excludeSatList=excludeSatList)
        #print(len(sat_atoms), len(sat_atoms_list))
        groups = []
        for i in range(len(center_atoms)):
            sat_atom_neighbors = []
            list_neighbors = self.find_firstneighbors(center_atoms[i], sat_atoms, struct.B)
            for j in list_neighbors:
                sat_atom_neighbors.append(sat_atoms_list[j])
            groups.append([center_atoms_list[i], sat_atom_neighbors])
            
            #sys.stdout.write(&#34;%3.3f%%\r&#34; % (100*(i+1)/len(center_atoms)))
            #sys.stdout.flush()

        return groups

    # Sometimes atoms go out of the simulation box. Bound box. Whatever.
    # And sometimes we want them out to understand the structure.
    # So I add here a wrapper for:
    #   1) Application of periodic boundary conditions.
    #   2) Unbound atoms.
    # The code here works in fractional coordinates. 
    # You can provide a structure, or a set of atoms,
    # or a cartesian set of atoms + basis...
    # Or at least, it will do that. For now, at_frac.
    @calculate_time
    def handle_periodic_boundaries(self, at_frac, mode=&#39;bound&#39;):
        if mode != &#39;bound&#39; or mode != &#39;unbound&#39;:
            print(&#34;PBC handler: using mode &#39;bound&#39; by default (input not recognized)&#34;)
            mode = &#39;bound&#39;
            #CONTINUE_HERE

    # This function searches for a periodic image of periodic_atom
    # that is the nearest to fixed_atom. Returns the best periodic
    # image found, and the key [k_x, k_y, k_z] necessary to transform it.
    @calculate_time
    def findBestPairPeriodic_test(self, fixed_atom, periodic_atom, basis):
        mindist = 1E3
        best_transform = np.copy(periodic_atom)
        best_transform_key = np.array([0,0,0], dtype=float)
        # We search 1 cell around the boundary
        # Maybe we can search in a decomposed way i&gt;j&gt;k?????
        for axis in range(3):
            transform_key = np.copy(best_transform_key)
            for i in range(-1, 2):
                transform_key[axis] = i
                transformed_atom = periodic_atom + basis[0]*transform_key[0] + basis[1]*transform_key[1] + basis[2]*transform_key[2]
                vec = fixed_atom-transformed_atom
                dist = np.sqrt(np.dot(vec, vec))
                if (dist-mindist) &lt; 0.0:
                    mindist = dist + 0.0
                    best_transform = np.copy(transformed_atom)
                    best_transform_key[axis] = i

        return best_transform, best_transform_key

    @calculate_time
    def findBestPairPeriodic_GPT(self, fixed_atom, periodic_atom, basis):
        translations = np.array([i*basis[0] + j*basis[1] + k*basis[2] for i in range(-1,2) for j in range(-1,2) for k in range(-1,2)])
        #transformed_atoms = periodic_atom + translations
        #print(translations)
        transformed_atoms = np.array([periodic_atom + translations[i] for i in range(len(translations))])
        #print(transformed_atoms)
        #vec = fixed_atom - transformed_atoms
        vec = np.array([fixed_atom + transformed_atoms[i] for i in range(len(transformed_atoms))])
        dist = np.linalg.norm(vec, axis=1)
        min_index = np.argmin(dist)
        #print(np.min(dist), min_index)
        return transformed_atoms[min_index], [min_index//9-1, (min_index//3)%3-1, min_index%3-1]

    # This function searches for a periodic image of periodic_atom
    # that is the nearest to fixed_atom. Returns the best periodic
    # image found, and the key [k_x, k_y, k_z] necessary to transform it.
    @calculate_time
    def findBestPairPeriodic(self, fixed_atom, periodic_atom, basis):
        mindist = 1E3
        best_transform = np.copy(periodic_atom)
        transform_key = [0,0,0]
        # We search 1 cell around the boundar
        &#34;&#34;&#34;
        bi, bj, bk = 0, 0, 0
        for i in range(-1, 2):
            transformed_atom = periodic_atom + basis[0]*float(i) + basis[1]*float(bj) + basis[2]*float(bk)
            vec = fixed_atom-transformed_atom
            dist = np.sqrt(np.dot(vec, vec))
            try:
                if (dist-mindist) &lt; 0.0:
                    mindist = dist
                    best_transform = np.copy(transformed_atom)
                    bi = i
            except:
                print(&#34;IT BROKE! findBestPeriodic doesn&#39;t work well!&#34;, dist, mindist, vec)
                sys.exit()

        for j in range(-1, 2):
            transformed_atom = periodic_atom + basis[0]*float(bi) + basis[1]*float(j) + basis[2]*float(bk)
            vec = fixed_atom-transformed_atom
            dist = np.sqrt(np.dot(vec, vec))
            try:
                if (dist-mindist) &lt; 0.0:
                    mindist = dist
                    best_transform = np.copy(transformed_atom)
                    bj = j
            except:
                print(&#34;IT BROKE! findBestPeriodic doesn&#39;t work well!&#34;, dist, mindist, vec)
                sys.exit()

        for k in range(-1, 2):
            transformed_atom = periodic_atom + basis[0]*float(bi) + basis[1]*float(bj) + basis[2]*float(k)
            vec = fixed_atom-transformed_atom
            dist = np.sqrt(np.dot(vec, vec))
            try:
                if (dist-mindist) &lt; 0.0:
                    mindist = dist
                    best_transform = np.copy(transformed_atom)
                    bk = k
            except:
                print(&#34;IT BROKE! findBestPeriodic doesn&#39;t work well!&#34;, dist, mindist, vec)
                sys.exit()

        transform_key = [bi, bj, bk]
        &#34;&#34;&#34;
        for i in range(-1, 2):
            for j in range(-1, 2):
                for k in range(-1, 2):
                    transformed_atom = periodic_atom + basis[0]*float(i) + basis[1]*float(j) + basis[2]*float(k)                
                    vec = fixed_atom-transformed_atom
                    dist = np.sqrt(np.dot(vec, vec))
                    #print(transformed_atom, dist, mindist, best_transform)
                    try:
                        if (dist-mindist) &lt; 0.0:
                            mindist = dist
                            best_transform = np.copy(transformed_atom)
                            transform_key = [i, j, k]
                    except:
                        print(&#34;IT BROKE! findBestPeriodic doesn&#39;t work well!&#34;, dist, mindist, vec)
                        sys.exit()
        
        return best_transform, transform_key

    @calculate_time
    def atom_transform(self, atom, basis, key):
        return atom + basis[0]*float(key[0]) + basis[1]*float(key[1]) + basis[2]*float(key[2])

    # Function to find pairs of atoms. Input can be in standard .at_frac
    # Returns the pair[atom1]=atom2 and the keyring [k_x, k_y, k_z] for the periodic images.
    @calculate_time
    def find_pairs(self, atoms1, atoms2, box2):
        pair = np.zeros([len(atoms1)], dtype=int)
        pair[:] -= 1
        mindist_pair = np.zeros([len(atoms1)], dtype=float)
        mindist_pair[:] -= 1
        keyring = []
        listat2 = list(range(len(atoms2)))
        for i in range(len(atoms1)):
            threshold = 1E3 # This is just an init parameter
            for j in listat2:
                atoms2periodic, transform_key = self.findBestPairPeriodic_test(atoms1[i], atoms2[j], box2)
                dvec = np.copy(atoms1[i]-atoms2periodic)
                dist = np.sqrt(np.dot(dvec, dvec))
                # This is unclean but efficient. Basically, checks that the new transformation
                # provides a smaller distance between pairs of atoms. Probably can be cleaned.
                if (dist-threshold) &lt; 0.0:
                    threshold = dist + 0.0
                    pair[i] = j
                    best_transform_key = transform_key
            if pair[i] in listat2: listat2.remove(pair[i])
            keyring.append(best_transform_key)
            mindist_pair[i] = threshold + 0.0

        for i, a2 in enumerate(pair):
            # This warning should be set to an actual threshold parameter
            if mindist_pair[i] &gt; 2.5 and a2 &gt; -1: print(&#34;WARNING with pair %d %d min distance: %.5f&#34; % (i, a2, mindist_pair[i]))
            #print(&#34;Pair %d %d: %.5f&#34; % (i, a2, mindist_pair[i]), atoms1[i], atoms2[a2], keyring[i]) # DEBUG

        return pair, keyring

    # A quicker function to find keys of known pairs of atoms
    @calculate_time
    def refresh_key(self, atoms1, atoms2, box2, pairs):
        key = []
        for at1, at2 in enumerate(pairs):
            atoms2periodic, transform_key = self.findBestPairPeriodic_test(atoms1[at1], atoms2[at2], box2)
            key.append(transform_key)
        return key

    # Key is for the atom 2.
    @calculate_time
    def build_vectormap(self, atoms1, atoms2, box, pairs, initial_key):
        vectors = np.zeros([len(atoms1), 3], dtype=float)
        key = initial_key + .0
        d = []
        for i, j in enumerate(pairs):
            atoms2_pos_correction = key[i][0]*box[0] + key[i][1]*box[1] + key[i][2]*box[2]
            vec = atoms1[i] - (atoms2[j] + atoms2_pos_correction)
            vectors[i] = np.copy(vec)
            d.append(np.sqrt(np.dot(vec,vec)))
            #print(d[-1]) 
        # The tolerance should probably be a parameter
        if (np.max(np.array(d, dtype=float)) &gt; 2.5):
            key = self.refresh_key(atoms1, atoms2, box, pairs)
            d = []
            for i, j in enumerate(pairs):
                atoms2_pos_correction = key[i][0]*box[0] + key[i][1]*box[1] + key[i][2]*box[2]
                vec = atoms1[i] - (atoms2[j] + atoms2_pos_correction)
                vectors[i] = np.copy(vec)
                dist = np.sqrt(np.dot(vec, vec))
                d.append(dist)
        
        # Just a check
        if (np.max(np.array(d, dtype=float)) &gt; 2.5):
            print(&#34;Max distance between atoms is larger than 2.5&#34;)
            sys.exit()

        return vectors, key

    def compute_angles_MD_GPT(self, vectors, vec_of_vecs=False):
        num_steps, num_vecs = vectors.shape[:2]
        e_x = np.array([1, 0, 0], dtype=np.float32)
        e_z = np.array([0, 0, 1], dtype=np.float32)
        v_pbc = vectors - np.einsum(&#39;ij,j-&gt;ij&#39;, vectors, e_x) * e_x
        v_pab = vectors - np.einsum(&#39;ij,j-&gt;ij&#39;, vectors, e_z) * e_z
        norm_vpbc = np.linalg.norm(v_pbc, axis=-1)
        norm_vpab = np.linalg.norm(v_pab, axis=-1)
        phi = np.arctan2(np.cross(v_pab, e_z), np.dot(v_pab, e_x))
        theta = np.arccos(np.einsum(&#39;ij,j-&gt;i&#39;, vectors, e_z) / norm_vpbc)
        ctheta = np.cos(theta)
        if vec_of_vecs:
            angles = np.concatenate((phi.reshape(-1,1), theta.reshape(-1,1)), axis=1)
            return angles.reshape(num_steps, num_vecs, 2)
        else:
            return phi, theta, ctheta

    @calculate_time
    def compute_angles_MD(self, vectors, vec_of_vecs=False):
        num_steps = len(vectors)
        num_vecs = len(vectors[0])
        theta = np.zeros([num_steps*num_vecs], dtype=float)
        phi = np.zeros([num_steps*num_vecs], dtype=float)
        ctheta = np.zeros([num_steps*num_vecs], dtype=float)

        e_x = np.eye(3, dtype=float)[0,:]
        e_z = np.eye(3, dtype=float)[2,:]
        angles = []
        for i in range(num_steps):
            angles_inner = []
            for j in range(num_vecs):
                vec = np.copy(vectors[i,j])

                v_pbc = vec - np.dot(vec, e_x)*e_x
                v_pab = vec - np.dot(vec, e_z)*e_z
                norm_vpbc = np.sqrt(np.dot(v_pbc, v_pbc))
                norm_vpab = np.sqrt(np.dot(v_pab, v_pab))
                # Angles = [\phi, \theta]
                phi[i*num_vecs+j] = self.calculate_angle_full(e_x, v_pab/norm_vpab, e_z) + 0.0
                theta[i*num_vecs+j] = self.calculate_angle(e_z, vec)#angle(e_z, v_pbc/norm_vpbc, e_x) + 0.0
                ctheta[i*num_vecs+j] = np.cos(theta[i*num_vecs+j])
                angles_inner.append([phi[i*num_vecs+j], theta[i*num_vecs+j]])
            angles.append(angles_inner)

        angles = np.array(angles)

        if vec_of_vecs == False:
            return phi, theta, ctheta
        else:
            return angles</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ctoolkit.tools.cellOperations.cellOperations"><code class="flex name class">
<span>class <span class="ident">cellOperations</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class cellOperations:
    def __init__(self):
        pass

    @calculate_time
    def func3(self):
        time.sleep(3)   

    @calculate_time
    def frac_to_cart(self, B, atom_set):
        new_atom_set = np.dot(B, atom_set.T).T
        
        return new_atom_set

    @calculate_time
    def cart_to_frac(self, B, atom_set):
        Binv = np.linalg.inv(B)
        new_atom_set = np.dot(Binv, atom_set.T).T

        return new_atom_set

    def rigid_displacement(self, vector, structure):
        new_cart = np.zeros([len(structure.at_cart), 3], dtype=float)
        new_frac = np.zeros([len(structure.at_frac), 3], dtype=float)
        vector = np.array(vector, dtype=float)

        disp = np.zeros([3], dtype=float)
        for i in range(3):
            disp += vector[i]*structure.B[i,:]

        for atom in range(len(structure.at_cart)):
            new_cart[atom] = np.copy(structure.at_cart[atom] + disp)
            
        structure.at_cart = np.copy(new_cart)
        structure.recalculate_poscar()

    def apply_rotation(self, vector, angle, axis, origin=None):
        # The idea: 
        # We want to rotate a group of atoms. The positions
        # of the atoms are given as vectors from the crystallographic
        # origin of coordinates. Thus what we want to do is:
        #   move origin -&gt; apply rotation along given axis -&gt; go back to crystal. origin

        # We use the tensorial form of the rotation operator
        axis = np.array(axis)
        axis = axis/(np.sqrt(np.dot(axis, axis)))
        cross = np.zeros([3,3], dtype=float)
        cart = np.array([[1.0, .0, .0], [.0, 1.0, .0], [.0, .0, 1.0]], dtype=float)
        for i in range(3):
            c1 = np.cross(axis, cart[i])
            cross += np.outer(c1, cart[i])
        R = np.cos(angle)*np.eye(3,3) + (np.sin(angle))*(cross) + (1-np.cos(angle))*(np.outer(axis, axis))

        # Now we move the origin, compute, and go back to the crystal. origin. All packed.
        if origin is None:
            origin = np.zeros([3], dtype=float)
        
        return np.dot(R, vector - origin) + origin
        
    def rigid_rotation(self, vector_list, angle, axis, origin=None):
        if len(vector_list.shape) &lt; 2:
            return self.apply_rotation(vector_list, angle, axis, origin)
        else:
            veclist = []
            for i in range(len(vector_list)):
                veclist.append(self.apply_rotation(vector_list[i], angle, axis, origin))
            return np.array(veclist, dtype=float)

    def new_supercell_VASP(self, N, VASP_struct):
        new_VASP = self.copy_structure(VASP_struct)
        # Objects can be different...

        new_structure = new_VASP.POSCAR
        new_structure.at_frac = np.zeros([np.prod(N)*len(VASP_struct.POSCAR.at_frac), 3])
        ct_atom = 0
        ct2 = 0
        new_structure.namelist = [&#39;&#39;]
        new_structure.atom_id =  []
        for specie_id, specie in enumerate(VASP_struct.POSCAR.names):
            new_structure.multiplicity[specie_id] = VASP_struct.POSCAR.multiplicity[specie_id]*np.prod(N)
            for atom in range(VASP_struct.POSCAR.multiplicity[specie_id]):
            #for nx, ny, nz in [(nx, ny, nz) for nx in range(N[0]) for ny in range(N[1]) for nz in range(N[2])]:
                #for atom in range(structure.multiplicity[specie_id]):
                for nx, ny, nz in [(nx, ny, nz) for nx in range(N[0]) for ny in range(N[1]) for nz in range(N[2])]: #This inverts how the atoms are printed
                    Id = np.eye(3)
                    cell_vector = nx*Id[0] + ny*Id[1] + nz*Id[2]

                    # Frac coordinates need to be reescaled to the new supercell
                    temp_vec = np.copy(VASP_struct.POSCAR.at_frac[ct2] + cell_vector)
                    for i in range(3):
                        new_structure.at_frac[ct_atom, i] = temp_vec[i]/N[i]
                    new_structure.namelist.append(VASP_struct.POSCAR.namelist[ct2])
                    new_structure.atom_id.append(VASP_struct.POSCAR.atom_id[ct2])
                    ct_atom += 1
                ct2 += 1

        for i in range(3):
            new_structure.B[i] = np.copy(VASP_struct.POSCAR.B[i]*N[i])

        new_structure.at_cart = np.copy(self.frac_to_cart(new_structure.B, new_structure.at_frac))

        mult = float(len(VASP_struct.POSCAR.at_frac))/float(len(new_structure.at_frac))
        new_structure.volume *= mult
        #new_structure.energy *= mult

        return new_structure

    def new_supercell(self, N, structure):
        # We select and divide into smaller functions as a sort of override
        if structure.type == &#39;VASP&#39;:
            new_structure = self.new_supercell_VASP(N, structure)

        return new_structure

    # Add atoms given a vector
    def spawn_cell_frac(self, vector, structure):
        new_frac = np.copy(structure.at_frac)
        for i in range(len(new_frac)):
            new_frac[i] = structure.at_frac[i] + np.array(vector, dtype=float)

        return np.copy(new_frac)

    def spawn_cell_invfrac(self, vector, structure):
        new_frac = np.copy(structure.at_frac)
        tol = 0.02
        for i in range(len(new_frac)):
            &#34;&#34;&#34;
            temp_vec = -structure.at_frac[i] + np.array([1,1,1], dtype=float)
            # Correct frac on the fly
            for i in range(3):
                if(np.abs(temp_vec[i]-1.0) &lt; tol):
                    temp_vec[i] -= 0.0#1.0

            #new_frac[i] = temp_vec + np.array(vector, dtype=float)
            &#34;&#34;&#34;

            # We go to [-1,-1,-1] and then invert!
            temp_vec = -(structure.at_frac[i] + np.array([-1,-1,-1], dtype=float))
            # Correct frac on the fly
            for j in range(3):
                if(np.abs(temp_vec[j]-1.0) &lt; tol):
                    temp_vec[j] -= 1.0

            new_frac[i] = temp_vec + np.array(vector, dtype=float)
            #new_frac[i] = np.array(vector, dtype=float)-structure.at_frac[i] + np.array([-1,-1,-1], dtype=float)

        return np.copy(new_frac)

    def centrosymmetric_supercell_VASP(self, VASP_structure):
        new_VASP = self.copy_structure(VASP_structure)
        new_structure = new_VASP.POSCAR

        # Centrosymmetry requires an atom well located for the origin.
        # Thus we need to shift to set the zero (for now experimental)
        shifted_structure = self.copy_structure(structure).POSCAR
        for i in range(len(shifted_structure.at_frac)):
            shifted_structure.at_frac[i] -= structure.at_frac[0]

        cells = []
        &#34;&#34;&#34;
        for i, j in [(i,j) for i in range(2) for j in range(2)]:
            cells.append(self.spawn_cell_frac([i,j,0], shifted_structure))
        for i, j in [(i,j) for i in range(2) for j in range(2)]:
            cells.append(self.spawn_cell_invfrac([i,j,1], shifted_structure))
        &#34;&#34;&#34;
        # Test: only 2 cells
        cells.append(self.spawn_cell_frac([0,0,0], shifted_structure))
        cells.append(self.spawn_cell_invfrac([0,0,1], shifted_structure))
        N = [1,1,2]
        ct = 0
        ct2 = 0
        new_structure.at_frac = np.zeros([np.prod(N)*len(structure.at_frac), 3])
        new_structure.namelist = [&#39;&#39;]
        new_structure.atom_id = []
        for specie_id, specie in enumerate(structure.names):
            new_structure.multiplicity[specie_id] = structure.multiplicity[specie_id]*np.prod(N)
            for atom in range(structure.multiplicity[specie_id]):
                for cell in cells:
                    # Frac coordinates need to be reescaled to the new supercell
                    temp_vec = np.copy(cell[ct2])
                    for i in range(3):
                        new_structure.at_frac[ct, i] = temp_vec[i]/N[i]
                    new_structure.atom_id.append(structure.atom_id[ct2])
                    new_structure.namelist.append(structure.namelist[ct2])
                    ct += 1
                ct2 += 1

        for i in range(3):
            new_structure.B[i] = np.copy(structure.B[i]*N[i])

        new_structure.at_cart = np.copy(self.frac_to_cart(new_structure.B, new_structure.at_frac))

        mult = float(len(VASP_struct.POSCAR.at_frac))/float(len(new_structure.at_frac))
        new_structure.volume *= mult
        new_structure.energy *= mult

        return new_structure

    def centrosymmetric_supercell(self, structure):
        # We select and divide into smaller functions as a sort of override
        if structure.type == &#39;VASP&#39;:
            new_structure = self.new_supercell_VASP(N, structure)

        return new_structure

    def interpolate_structures_VASP(self, struct1, struct2, num_images):
        structures = []
        structures.append(struct1)
        for i in range(1, num_images+1):
            # Load structure + cleanup of frac coordinates
            new_VASP = self.copy_structure(struct1)
            new_structure = new_VASP.POSCAR
            new_structure.frac_image_sniper()
            # Linear interpolation of cell &amp; frac &amp; cart

            new_structure.B = struct1.POSCAR.B + float(i)/(num_images+2)*(struct2.POSCAR.B-struct1.POSCAR.B)
            new_structure.at_frac = struct1.POSCAR.at_frac + float(i)/(num_images+2)*(struct2.POSCAR.at_frac-struct1.POSCAR.at_frac)
            # Could put a control for running images here
            new_structure.at_cart = self.frac_to_cart(new_structure.B, new_structure.at_frac)#struct1.at_cart + float(i/(num_images+2))*(struct2.at_cart-struct1.at_cart)
            # Probably useless or troublesome:
            new_structure.frac_image_sniper()
            structures.append(new_VASP)

        structures.append(struct2)

        return structures

    def interpolate_structures(self, struct1, struct2, num_images):
        # We select and divide into smaller functions as a sort of override
        if struct1.type != struct2.type:
            print(&#39;Error! Structures in different format. Transform them first!&#39;)
            sys.exit()
            # Attempt conversion
            #print(&#39;Attempting to unify types...&#39;)
            #struct1 = self.transform_type(struct1, struct2.type)
            #print(&#34;Successfully transformed type of structure 1 (%s) into %s!&#34; % (struct1.type, struct2.type))

        if struct1.type == &#39;VASP&#39;:
           structures = self.interpolate_structures_VASP(struct1, struct2, num_images)

        return structures

    @calculate_time
    def find_firstneighbors(self, atom, satellites, basis):
        d = np.zeros([len(satellites)], dtype=float)
        tol = 20 # in percentage
        for i in range(len(satellites)):
            best_transform, transform_key = self.findBestPairPeriodic(atom, satellites[i], basis)
            dist = np.sqrt(np.dot(atom-best_transform, atom-best_transform))
            # We exclude the &#34;self&#34; atom
            if(dist &gt; 0.0):
                d[i] = dist
            else:
                d[i] = 1E5
        #print(np.sort(d)) 
        min_dist = np.min(d)
        list_neighbors = []
        for i in range(len(satellites)):
            if d[i] &lt; min_dist*(1+tol/100):
                #print(i, d[i], min_dist*(1+tol/100))
                list_neighbors.append(i)

        return list_neighbors

    def find_full_molecules(self, struct, center, satellite, num_neighbors=0):
        center_atoms = struct.filter_atoms(center)
        sat_atoms = struct.filter_atoms(satellite)
        all_atoms = np.copy(struct.at_cart)

        center_atoms_list = struct.filter_atoms_list(center)
        sat_atoms_list = struct.filter_atoms_list(satellite)

        groups = []
        nice_molecules = []
        for i in range(len(center_atoms)):
            nice_molecule = []
            sat_atom_neighbors = []
            list_neighbors = self.find_firstneighbors(center_atoms[i], sat_atoms, struct.B)

            for j in list_neighbors:
                sat_atom_neighbors.append(sat_atoms_list[j])

            if num_neighbors==1:
                # center atom new first neighbors
                cfn_bulk = self.find_firstneighbors(center_atoms[i], all_atoms, struct.B)
                cfn_list = []
                for cfn in cfn_bulk:
                    if ((cfn not in center_atoms_list) and
                        (cfn not in sat_atom_neighbors)):
                        cfn_list.append(cfn)

                # find the first neighbors of every satellite
                sfn_list_col = []
                for j in sat_atom_neighbors:
                    sfn_bulk = self.find_firstneighbors(struct.at_cart[j], all_atoms, struct.B)
                    sfn_list = []
                    for sfn in sfn_bulk:
                        if ((sfn not in center_atoms_list) and 
                            (sfn not in sat_atom_neighbors) and
                            (sfn not in cfn_list)): 
                            sfn_list.append(sfn)

                    sfn_list_col.append(sfn_list)
                 
                groups.append([center_atoms_list[i], sat_atom_neighbors, cfn_list, sfn_list_col])
                nice_molecule.append(center_atoms_list[i])
                for sat in sat_atom_neighbors: nice_molecule.append(sat)
                for cfn in cfn_list: nice_molecule.append(cfn)
                for sfn in sfn_list: nice_molecule.append(sfn)
                nice_molecules.append(nice_molecule)
            else:
                groups.append([center_atoms_list[i], sat_atom_neighbors])

            sys.stdout.write(&#34;%3.3f%%\r&#34; % (100*(i+1)/len(center_atoms)))
            sys.stdout.flush()

        return groups, nice_molecules

    # Find groups of atoms between the CENTER
    # of the interaction and the SATELLITE possible
    # atoms belonging to a particular species
    @calculate_time
    def find_groups(self, struct, center, satellite, excludeSatList=[]):
        center_atoms = struct.filter_atoms(center)
        sat_atoms = struct.filter_atoms(satellite, excludeSatList=excludeSatList)
        center_atoms_list = struct.filter_atoms_list(center)
        sat_atoms_list = struct.filter_atoms_list(satellite, excludeSatList=excludeSatList)
        #print(len(sat_atoms), len(sat_atoms_list))
        groups = []
        for i in range(len(center_atoms)):
            sat_atom_neighbors = []
            list_neighbors = self.find_firstneighbors(center_atoms[i], sat_atoms, struct.B)
            for j in list_neighbors:
                sat_atom_neighbors.append(sat_atoms_list[j])
            groups.append([center_atoms_list[i], sat_atom_neighbors])
            
            #sys.stdout.write(&#34;%3.3f%%\r&#34; % (100*(i+1)/len(center_atoms)))
            #sys.stdout.flush()

        return groups

    # Sometimes atoms go out of the simulation box. Bound box. Whatever.
    # And sometimes we want them out to understand the structure.
    # So I add here a wrapper for:
    #   1) Application of periodic boundary conditions.
    #   2) Unbound atoms.
    # The code here works in fractional coordinates. 
    # You can provide a structure, or a set of atoms,
    # or a cartesian set of atoms + basis...
    # Or at least, it will do that. For now, at_frac.
    @calculate_time
    def handle_periodic_boundaries(self, at_frac, mode=&#39;bound&#39;):
        if mode != &#39;bound&#39; or mode != &#39;unbound&#39;:
            print(&#34;PBC handler: using mode &#39;bound&#39; by default (input not recognized)&#34;)
            mode = &#39;bound&#39;
            #CONTINUE_HERE

    # This function searches for a periodic image of periodic_atom
    # that is the nearest to fixed_atom. Returns the best periodic
    # image found, and the key [k_x, k_y, k_z] necessary to transform it.
    @calculate_time
    def findBestPairPeriodic_test(self, fixed_atom, periodic_atom, basis):
        mindist = 1E3
        best_transform = np.copy(periodic_atom)
        best_transform_key = np.array([0,0,0], dtype=float)
        # We search 1 cell around the boundary
        # Maybe we can search in a decomposed way i&gt;j&gt;k?????
        for axis in range(3):
            transform_key = np.copy(best_transform_key)
            for i in range(-1, 2):
                transform_key[axis] = i
                transformed_atom = periodic_atom + basis[0]*transform_key[0] + basis[1]*transform_key[1] + basis[2]*transform_key[2]
                vec = fixed_atom-transformed_atom
                dist = np.sqrt(np.dot(vec, vec))
                if (dist-mindist) &lt; 0.0:
                    mindist = dist + 0.0
                    best_transform = np.copy(transformed_atom)
                    best_transform_key[axis] = i

        return best_transform, best_transform_key

    @calculate_time
    def findBestPairPeriodic_GPT(self, fixed_atom, periodic_atom, basis):
        translations = np.array([i*basis[0] + j*basis[1] + k*basis[2] for i in range(-1,2) for j in range(-1,2) for k in range(-1,2)])
        #transformed_atoms = periodic_atom + translations
        #print(translations)
        transformed_atoms = np.array([periodic_atom + translations[i] for i in range(len(translations))])
        #print(transformed_atoms)
        #vec = fixed_atom - transformed_atoms
        vec = np.array([fixed_atom + transformed_atoms[i] for i in range(len(transformed_atoms))])
        dist = np.linalg.norm(vec, axis=1)
        min_index = np.argmin(dist)
        #print(np.min(dist), min_index)
        return transformed_atoms[min_index], [min_index//9-1, (min_index//3)%3-1, min_index%3-1]

    # This function searches for a periodic image of periodic_atom
    # that is the nearest to fixed_atom. Returns the best periodic
    # image found, and the key [k_x, k_y, k_z] necessary to transform it.
    @calculate_time
    def findBestPairPeriodic(self, fixed_atom, periodic_atom, basis):
        mindist = 1E3
        best_transform = np.copy(periodic_atom)
        transform_key = [0,0,0]
        # We search 1 cell around the boundar
        &#34;&#34;&#34;
        bi, bj, bk = 0, 0, 0
        for i in range(-1, 2):
            transformed_atom = periodic_atom + basis[0]*float(i) + basis[1]*float(bj) + basis[2]*float(bk)
            vec = fixed_atom-transformed_atom
            dist = np.sqrt(np.dot(vec, vec))
            try:
                if (dist-mindist) &lt; 0.0:
                    mindist = dist
                    best_transform = np.copy(transformed_atom)
                    bi = i
            except:
                print(&#34;IT BROKE! findBestPeriodic doesn&#39;t work well!&#34;, dist, mindist, vec)
                sys.exit()

        for j in range(-1, 2):
            transformed_atom = periodic_atom + basis[0]*float(bi) + basis[1]*float(j) + basis[2]*float(bk)
            vec = fixed_atom-transformed_atom
            dist = np.sqrt(np.dot(vec, vec))
            try:
                if (dist-mindist) &lt; 0.0:
                    mindist = dist
                    best_transform = np.copy(transformed_atom)
                    bj = j
            except:
                print(&#34;IT BROKE! findBestPeriodic doesn&#39;t work well!&#34;, dist, mindist, vec)
                sys.exit()

        for k in range(-1, 2):
            transformed_atom = periodic_atom + basis[0]*float(bi) + basis[1]*float(bj) + basis[2]*float(k)
            vec = fixed_atom-transformed_atom
            dist = np.sqrt(np.dot(vec, vec))
            try:
                if (dist-mindist) &lt; 0.0:
                    mindist = dist
                    best_transform = np.copy(transformed_atom)
                    bk = k
            except:
                print(&#34;IT BROKE! findBestPeriodic doesn&#39;t work well!&#34;, dist, mindist, vec)
                sys.exit()

        transform_key = [bi, bj, bk]
        &#34;&#34;&#34;
        for i in range(-1, 2):
            for j in range(-1, 2):
                for k in range(-1, 2):
                    transformed_atom = periodic_atom + basis[0]*float(i) + basis[1]*float(j) + basis[2]*float(k)                
                    vec = fixed_atom-transformed_atom
                    dist = np.sqrt(np.dot(vec, vec))
                    #print(transformed_atom, dist, mindist, best_transform)
                    try:
                        if (dist-mindist) &lt; 0.0:
                            mindist = dist
                            best_transform = np.copy(transformed_atom)
                            transform_key = [i, j, k]
                    except:
                        print(&#34;IT BROKE! findBestPeriodic doesn&#39;t work well!&#34;, dist, mindist, vec)
                        sys.exit()
        
        return best_transform, transform_key

    @calculate_time
    def atom_transform(self, atom, basis, key):
        return atom + basis[0]*float(key[0]) + basis[1]*float(key[1]) + basis[2]*float(key[2])

    # Function to find pairs of atoms. Input can be in standard .at_frac
    # Returns the pair[atom1]=atom2 and the keyring [k_x, k_y, k_z] for the periodic images.
    @calculate_time
    def find_pairs(self, atoms1, atoms2, box2):
        pair = np.zeros([len(atoms1)], dtype=int)
        pair[:] -= 1
        mindist_pair = np.zeros([len(atoms1)], dtype=float)
        mindist_pair[:] -= 1
        keyring = []
        listat2 = list(range(len(atoms2)))
        for i in range(len(atoms1)):
            threshold = 1E3 # This is just an init parameter
            for j in listat2:
                atoms2periodic, transform_key = self.findBestPairPeriodic_test(atoms1[i], atoms2[j], box2)
                dvec = np.copy(atoms1[i]-atoms2periodic)
                dist = np.sqrt(np.dot(dvec, dvec))
                # This is unclean but efficient. Basically, checks that the new transformation
                # provides a smaller distance between pairs of atoms. Probably can be cleaned.
                if (dist-threshold) &lt; 0.0:
                    threshold = dist + 0.0
                    pair[i] = j
                    best_transform_key = transform_key
            if pair[i] in listat2: listat2.remove(pair[i])
            keyring.append(best_transform_key)
            mindist_pair[i] = threshold + 0.0

        for i, a2 in enumerate(pair):
            # This warning should be set to an actual threshold parameter
            if mindist_pair[i] &gt; 2.5 and a2 &gt; -1: print(&#34;WARNING with pair %d %d min distance: %.5f&#34; % (i, a2, mindist_pair[i]))
            #print(&#34;Pair %d %d: %.5f&#34; % (i, a2, mindist_pair[i]), atoms1[i], atoms2[a2], keyring[i]) # DEBUG

        return pair, keyring

    # A quicker function to find keys of known pairs of atoms
    @calculate_time
    def refresh_key(self, atoms1, atoms2, box2, pairs):
        key = []
        for at1, at2 in enumerate(pairs):
            atoms2periodic, transform_key = self.findBestPairPeriodic_test(atoms1[at1], atoms2[at2], box2)
            key.append(transform_key)
        return key

    # Key is for the atom 2.
    @calculate_time
    def build_vectormap(self, atoms1, atoms2, box, pairs, initial_key):
        vectors = np.zeros([len(atoms1), 3], dtype=float)
        key = initial_key + .0
        d = []
        for i, j in enumerate(pairs):
            atoms2_pos_correction = key[i][0]*box[0] + key[i][1]*box[1] + key[i][2]*box[2]
            vec = atoms1[i] - (atoms2[j] + atoms2_pos_correction)
            vectors[i] = np.copy(vec)
            d.append(np.sqrt(np.dot(vec,vec)))
            #print(d[-1]) 
        # The tolerance should probably be a parameter
        if (np.max(np.array(d, dtype=float)) &gt; 2.5):
            key = self.refresh_key(atoms1, atoms2, box, pairs)
            d = []
            for i, j in enumerate(pairs):
                atoms2_pos_correction = key[i][0]*box[0] + key[i][1]*box[1] + key[i][2]*box[2]
                vec = atoms1[i] - (atoms2[j] + atoms2_pos_correction)
                vectors[i] = np.copy(vec)
                dist = np.sqrt(np.dot(vec, vec))
                d.append(dist)
        
        # Just a check
        if (np.max(np.array(d, dtype=float)) &gt; 2.5):
            print(&#34;Max distance between atoms is larger than 2.5&#34;)
            sys.exit()

        return vectors, key

    def compute_angles_MD_GPT(self, vectors, vec_of_vecs=False):
        num_steps, num_vecs = vectors.shape[:2]
        e_x = np.array([1, 0, 0], dtype=np.float32)
        e_z = np.array([0, 0, 1], dtype=np.float32)
        v_pbc = vectors - np.einsum(&#39;ij,j-&gt;ij&#39;, vectors, e_x) * e_x
        v_pab = vectors - np.einsum(&#39;ij,j-&gt;ij&#39;, vectors, e_z) * e_z
        norm_vpbc = np.linalg.norm(v_pbc, axis=-1)
        norm_vpab = np.linalg.norm(v_pab, axis=-1)
        phi = np.arctan2(np.cross(v_pab, e_z), np.dot(v_pab, e_x))
        theta = np.arccos(np.einsum(&#39;ij,j-&gt;i&#39;, vectors, e_z) / norm_vpbc)
        ctheta = np.cos(theta)
        if vec_of_vecs:
            angles = np.concatenate((phi.reshape(-1,1), theta.reshape(-1,1)), axis=1)
            return angles.reshape(num_steps, num_vecs, 2)
        else:
            return phi, theta, ctheta

    @calculate_time
    def compute_angles_MD(self, vectors, vec_of_vecs=False):
        num_steps = len(vectors)
        num_vecs = len(vectors[0])
        theta = np.zeros([num_steps*num_vecs], dtype=float)
        phi = np.zeros([num_steps*num_vecs], dtype=float)
        ctheta = np.zeros([num_steps*num_vecs], dtype=float)

        e_x = np.eye(3, dtype=float)[0,:]
        e_z = np.eye(3, dtype=float)[2,:]
        angles = []
        for i in range(num_steps):
            angles_inner = []
            for j in range(num_vecs):
                vec = np.copy(vectors[i,j])

                v_pbc = vec - np.dot(vec, e_x)*e_x
                v_pab = vec - np.dot(vec, e_z)*e_z
                norm_vpbc = np.sqrt(np.dot(v_pbc, v_pbc))
                norm_vpab = np.sqrt(np.dot(v_pab, v_pab))
                # Angles = [\phi, \theta]
                phi[i*num_vecs+j] = self.calculate_angle_full(e_x, v_pab/norm_vpab, e_z) + 0.0
                theta[i*num_vecs+j] = self.calculate_angle(e_z, vec)#angle(e_z, v_pbc/norm_vpbc, e_x) + 0.0
                ctheta[i*num_vecs+j] = np.cos(theta[i*num_vecs+j])
                angles_inner.append([phi[i*num_vecs+j], theta[i*num_vecs+j]])
            angles.append(angles_inner)

        angles = np.array(angles)

        if vec_of_vecs == False:
            return phi, theta, ctheta
        else:
            return angles</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ctoolkit.tools.cellOperations.cellOperations.apply_rotation"><code class="name flex">
<span>def <span class="ident">apply_rotation</span></span>(<span>self, vector, angle, axis, origin=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_rotation(self, vector, angle, axis, origin=None):
    # The idea: 
    # We want to rotate a group of atoms. The positions
    # of the atoms are given as vectors from the crystallographic
    # origin of coordinates. Thus what we want to do is:
    #   move origin -&gt; apply rotation along given axis -&gt; go back to crystal. origin

    # We use the tensorial form of the rotation operator
    axis = np.array(axis)
    axis = axis/(np.sqrt(np.dot(axis, axis)))
    cross = np.zeros([3,3], dtype=float)
    cart = np.array([[1.0, .0, .0], [.0, 1.0, .0], [.0, .0, 1.0]], dtype=float)
    for i in range(3):
        c1 = np.cross(axis, cart[i])
        cross += np.outer(c1, cart[i])
    R = np.cos(angle)*np.eye(3,3) + (np.sin(angle))*(cross) + (1-np.cos(angle))*(np.outer(axis, axis))

    # Now we move the origin, compute, and go back to the crystal. origin. All packed.
    if origin is None:
        origin = np.zeros([3], dtype=float)
    
    return np.dot(R, vector - origin) + origin</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.cellOperations.cellOperations.atom_transform"><code class="name flex">
<span>def <span class="ident">atom_transform</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.cellOperations.cellOperations.build_vectormap"><code class="name flex">
<span>def <span class="ident">build_vectormap</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.cellOperations.cellOperations.cart_to_frac"><code class="name flex">
<span>def <span class="ident">cart_to_frac</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.cellOperations.cellOperations.centrosymmetric_supercell"><code class="name flex">
<span>def <span class="ident">centrosymmetric_supercell</span></span>(<span>self, structure)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def centrosymmetric_supercell(self, structure):
    # We select and divide into smaller functions as a sort of override
    if structure.type == &#39;VASP&#39;:
        new_structure = self.new_supercell_VASP(N, structure)

    return new_structure</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.cellOperations.cellOperations.centrosymmetric_supercell_VASP"><code class="name flex">
<span>def <span class="ident">centrosymmetric_supercell_VASP</span></span>(<span>self, VASP_structure)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def centrosymmetric_supercell_VASP(self, VASP_structure):
    new_VASP = self.copy_structure(VASP_structure)
    new_structure = new_VASP.POSCAR

    # Centrosymmetry requires an atom well located for the origin.
    # Thus we need to shift to set the zero (for now experimental)
    shifted_structure = self.copy_structure(structure).POSCAR
    for i in range(len(shifted_structure.at_frac)):
        shifted_structure.at_frac[i] -= structure.at_frac[0]

    cells = []
    &#34;&#34;&#34;
    for i, j in [(i,j) for i in range(2) for j in range(2)]:
        cells.append(self.spawn_cell_frac([i,j,0], shifted_structure))
    for i, j in [(i,j) for i in range(2) for j in range(2)]:
        cells.append(self.spawn_cell_invfrac([i,j,1], shifted_structure))
    &#34;&#34;&#34;
    # Test: only 2 cells
    cells.append(self.spawn_cell_frac([0,0,0], shifted_structure))
    cells.append(self.spawn_cell_invfrac([0,0,1], shifted_structure))
    N = [1,1,2]
    ct = 0
    ct2 = 0
    new_structure.at_frac = np.zeros([np.prod(N)*len(structure.at_frac), 3])
    new_structure.namelist = [&#39;&#39;]
    new_structure.atom_id = []
    for specie_id, specie in enumerate(structure.names):
        new_structure.multiplicity[specie_id] = structure.multiplicity[specie_id]*np.prod(N)
        for atom in range(structure.multiplicity[specie_id]):
            for cell in cells:
                # Frac coordinates need to be reescaled to the new supercell
                temp_vec = np.copy(cell[ct2])
                for i in range(3):
                    new_structure.at_frac[ct, i] = temp_vec[i]/N[i]
                new_structure.atom_id.append(structure.atom_id[ct2])
                new_structure.namelist.append(structure.namelist[ct2])
                ct += 1
            ct2 += 1

    for i in range(3):
        new_structure.B[i] = np.copy(structure.B[i]*N[i])

    new_structure.at_cart = np.copy(self.frac_to_cart(new_structure.B, new_structure.at_frac))

    mult = float(len(VASP_struct.POSCAR.at_frac))/float(len(new_structure.at_frac))
    new_structure.volume *= mult
    new_structure.energy *= mult

    return new_structure</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.cellOperations.cellOperations.compute_angles_MD"><code class="name flex">
<span>def <span class="ident">compute_angles_MD</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.cellOperations.cellOperations.compute_angles_MD_GPT"><code class="name flex">
<span>def <span class="ident">compute_angles_MD_GPT</span></span>(<span>self, vectors, vec_of_vecs=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_angles_MD_GPT(self, vectors, vec_of_vecs=False):
    num_steps, num_vecs = vectors.shape[:2]
    e_x = np.array([1, 0, 0], dtype=np.float32)
    e_z = np.array([0, 0, 1], dtype=np.float32)
    v_pbc = vectors - np.einsum(&#39;ij,j-&gt;ij&#39;, vectors, e_x) * e_x
    v_pab = vectors - np.einsum(&#39;ij,j-&gt;ij&#39;, vectors, e_z) * e_z
    norm_vpbc = np.linalg.norm(v_pbc, axis=-1)
    norm_vpab = np.linalg.norm(v_pab, axis=-1)
    phi = np.arctan2(np.cross(v_pab, e_z), np.dot(v_pab, e_x))
    theta = np.arccos(np.einsum(&#39;ij,j-&gt;i&#39;, vectors, e_z) / norm_vpbc)
    ctheta = np.cos(theta)
    if vec_of_vecs:
        angles = np.concatenate((phi.reshape(-1,1), theta.reshape(-1,1)), axis=1)
        return angles.reshape(num_steps, num_vecs, 2)
    else:
        return phi, theta, ctheta</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.cellOperations.cellOperations.findBestPairPeriodic"><code class="name flex">
<span>def <span class="ident">findBestPairPeriodic</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.cellOperations.cellOperations.findBestPairPeriodic_GPT"><code class="name flex">
<span>def <span class="ident">findBestPairPeriodic_GPT</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.cellOperations.cellOperations.findBestPairPeriodic_test"><code class="name flex">
<span>def <span class="ident">findBestPairPeriodic_test</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.cellOperations.cellOperations.find_firstneighbors"><code class="name flex">
<span>def <span class="ident">find_firstneighbors</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.cellOperations.cellOperations.find_full_molecules"><code class="name flex">
<span>def <span class="ident">find_full_molecules</span></span>(<span>self, struct, center, satellite, num_neighbors=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_full_molecules(self, struct, center, satellite, num_neighbors=0):
    center_atoms = struct.filter_atoms(center)
    sat_atoms = struct.filter_atoms(satellite)
    all_atoms = np.copy(struct.at_cart)

    center_atoms_list = struct.filter_atoms_list(center)
    sat_atoms_list = struct.filter_atoms_list(satellite)

    groups = []
    nice_molecules = []
    for i in range(len(center_atoms)):
        nice_molecule = []
        sat_atom_neighbors = []
        list_neighbors = self.find_firstneighbors(center_atoms[i], sat_atoms, struct.B)

        for j in list_neighbors:
            sat_atom_neighbors.append(sat_atoms_list[j])

        if num_neighbors==1:
            # center atom new first neighbors
            cfn_bulk = self.find_firstneighbors(center_atoms[i], all_atoms, struct.B)
            cfn_list = []
            for cfn in cfn_bulk:
                if ((cfn not in center_atoms_list) and
                    (cfn not in sat_atom_neighbors)):
                    cfn_list.append(cfn)

            # find the first neighbors of every satellite
            sfn_list_col = []
            for j in sat_atom_neighbors:
                sfn_bulk = self.find_firstneighbors(struct.at_cart[j], all_atoms, struct.B)
                sfn_list = []
                for sfn in sfn_bulk:
                    if ((sfn not in center_atoms_list) and 
                        (sfn not in sat_atom_neighbors) and
                        (sfn not in cfn_list)): 
                        sfn_list.append(sfn)

                sfn_list_col.append(sfn_list)
             
            groups.append([center_atoms_list[i], sat_atom_neighbors, cfn_list, sfn_list_col])
            nice_molecule.append(center_atoms_list[i])
            for sat in sat_atom_neighbors: nice_molecule.append(sat)
            for cfn in cfn_list: nice_molecule.append(cfn)
            for sfn in sfn_list: nice_molecule.append(sfn)
            nice_molecules.append(nice_molecule)
        else:
            groups.append([center_atoms_list[i], sat_atom_neighbors])

        sys.stdout.write(&#34;%3.3f%%\r&#34; % (100*(i+1)/len(center_atoms)))
        sys.stdout.flush()

    return groups, nice_molecules</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.cellOperations.cellOperations.find_groups"><code class="name flex">
<span>def <span class="ident">find_groups</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.cellOperations.cellOperations.find_pairs"><code class="name flex">
<span>def <span class="ident">find_pairs</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.cellOperations.cellOperations.frac_to_cart"><code class="name flex">
<span>def <span class="ident">frac_to_cart</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.cellOperations.cellOperations.func3"><code class="name flex">
<span>def <span class="ident">func3</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.cellOperations.cellOperations.handle_periodic_boundaries"><code class="name flex">
<span>def <span class="ident">handle_periodic_boundaries</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.cellOperations.cellOperations.interpolate_structures"><code class="name flex">
<span>def <span class="ident">interpolate_structures</span></span>(<span>self, struct1, struct2, num_images)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate_structures(self, struct1, struct2, num_images):
    # We select and divide into smaller functions as a sort of override
    if struct1.type != struct2.type:
        print(&#39;Error! Structures in different format. Transform them first!&#39;)
        sys.exit()
        # Attempt conversion
        #print(&#39;Attempting to unify types...&#39;)
        #struct1 = self.transform_type(struct1, struct2.type)
        #print(&#34;Successfully transformed type of structure 1 (%s) into %s!&#34; % (struct1.type, struct2.type))

    if struct1.type == &#39;VASP&#39;:
       structures = self.interpolate_structures_VASP(struct1, struct2, num_images)

    return structures</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.cellOperations.cellOperations.interpolate_structures_VASP"><code class="name flex">
<span>def <span class="ident">interpolate_structures_VASP</span></span>(<span>self, struct1, struct2, num_images)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate_structures_VASP(self, struct1, struct2, num_images):
    structures = []
    structures.append(struct1)
    for i in range(1, num_images+1):
        # Load structure + cleanup of frac coordinates
        new_VASP = self.copy_structure(struct1)
        new_structure = new_VASP.POSCAR
        new_structure.frac_image_sniper()
        # Linear interpolation of cell &amp; frac &amp; cart

        new_structure.B = struct1.POSCAR.B + float(i)/(num_images+2)*(struct2.POSCAR.B-struct1.POSCAR.B)
        new_structure.at_frac = struct1.POSCAR.at_frac + float(i)/(num_images+2)*(struct2.POSCAR.at_frac-struct1.POSCAR.at_frac)
        # Could put a control for running images here
        new_structure.at_cart = self.frac_to_cart(new_structure.B, new_structure.at_frac)#struct1.at_cart + float(i/(num_images+2))*(struct2.at_cart-struct1.at_cart)
        # Probably useless or troublesome:
        new_structure.frac_image_sniper()
        structures.append(new_VASP)

    structures.append(struct2)

    return structures</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.cellOperations.cellOperations.new_supercell"><code class="name flex">
<span>def <span class="ident">new_supercell</span></span>(<span>self, N, structure)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_supercell(self, N, structure):
    # We select and divide into smaller functions as a sort of override
    if structure.type == &#39;VASP&#39;:
        new_structure = self.new_supercell_VASP(N, structure)

    return new_structure</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.cellOperations.cellOperations.new_supercell_VASP"><code class="name flex">
<span>def <span class="ident">new_supercell_VASP</span></span>(<span>self, N, VASP_struct)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_supercell_VASP(self, N, VASP_struct):
    new_VASP = self.copy_structure(VASP_struct)
    # Objects can be different...

    new_structure = new_VASP.POSCAR
    new_structure.at_frac = np.zeros([np.prod(N)*len(VASP_struct.POSCAR.at_frac), 3])
    ct_atom = 0
    ct2 = 0
    new_structure.namelist = [&#39;&#39;]
    new_structure.atom_id =  []
    for specie_id, specie in enumerate(VASP_struct.POSCAR.names):
        new_structure.multiplicity[specie_id] = VASP_struct.POSCAR.multiplicity[specie_id]*np.prod(N)
        for atom in range(VASP_struct.POSCAR.multiplicity[specie_id]):
        #for nx, ny, nz in [(nx, ny, nz) for nx in range(N[0]) for ny in range(N[1]) for nz in range(N[2])]:
            #for atom in range(structure.multiplicity[specie_id]):
            for nx, ny, nz in [(nx, ny, nz) for nx in range(N[0]) for ny in range(N[1]) for nz in range(N[2])]: #This inverts how the atoms are printed
                Id = np.eye(3)
                cell_vector = nx*Id[0] + ny*Id[1] + nz*Id[2]

                # Frac coordinates need to be reescaled to the new supercell
                temp_vec = np.copy(VASP_struct.POSCAR.at_frac[ct2] + cell_vector)
                for i in range(3):
                    new_structure.at_frac[ct_atom, i] = temp_vec[i]/N[i]
                new_structure.namelist.append(VASP_struct.POSCAR.namelist[ct2])
                new_structure.atom_id.append(VASP_struct.POSCAR.atom_id[ct2])
                ct_atom += 1
            ct2 += 1

    for i in range(3):
        new_structure.B[i] = np.copy(VASP_struct.POSCAR.B[i]*N[i])

    new_structure.at_cart = np.copy(self.frac_to_cart(new_structure.B, new_structure.at_frac))

    mult = float(len(VASP_struct.POSCAR.at_frac))/float(len(new_structure.at_frac))
    new_structure.volume *= mult
    #new_structure.energy *= mult

    return new_structure</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.cellOperations.cellOperations.refresh_key"><code class="name flex">
<span>def <span class="ident">refresh_key</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.cellOperations.cellOperations.rigid_displacement"><code class="name flex">
<span>def <span class="ident">rigid_displacement</span></span>(<span>self, vector, structure)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rigid_displacement(self, vector, structure):
    new_cart = np.zeros([len(structure.at_cart), 3], dtype=float)
    new_frac = np.zeros([len(structure.at_frac), 3], dtype=float)
    vector = np.array(vector, dtype=float)

    disp = np.zeros([3], dtype=float)
    for i in range(3):
        disp += vector[i]*structure.B[i,:]

    for atom in range(len(structure.at_cart)):
        new_cart[atom] = np.copy(structure.at_cart[atom] + disp)
        
    structure.at_cart = np.copy(new_cart)
    structure.recalculate_poscar()</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.cellOperations.cellOperations.rigid_rotation"><code class="name flex">
<span>def <span class="ident">rigid_rotation</span></span>(<span>self, vector_list, angle, axis, origin=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rigid_rotation(self, vector_list, angle, axis, origin=None):
    if len(vector_list.shape) &lt; 2:
        return self.apply_rotation(vector_list, angle, axis, origin)
    else:
        veclist = []
        for i in range(len(vector_list)):
            veclist.append(self.apply_rotation(vector_list[i], angle, axis, origin))
        return np.array(veclist, dtype=float)</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.cellOperations.cellOperations.spawn_cell_frac"><code class="name flex">
<span>def <span class="ident">spawn_cell_frac</span></span>(<span>self, vector, structure)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spawn_cell_frac(self, vector, structure):
    new_frac = np.copy(structure.at_frac)
    for i in range(len(new_frac)):
        new_frac[i] = structure.at_frac[i] + np.array(vector, dtype=float)

    return np.copy(new_frac)</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.cellOperations.cellOperations.spawn_cell_invfrac"><code class="name flex">
<span>def <span class="ident">spawn_cell_invfrac</span></span>(<span>self, vector, structure)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spawn_cell_invfrac(self, vector, structure):
    new_frac = np.copy(structure.at_frac)
    tol = 0.02
    for i in range(len(new_frac)):
        &#34;&#34;&#34;
        temp_vec = -structure.at_frac[i] + np.array([1,1,1], dtype=float)
        # Correct frac on the fly
        for i in range(3):
            if(np.abs(temp_vec[i]-1.0) &lt; tol):
                temp_vec[i] -= 0.0#1.0

        #new_frac[i] = temp_vec + np.array(vector, dtype=float)
        &#34;&#34;&#34;

        # We go to [-1,-1,-1] and then invert!
        temp_vec = -(structure.at_frac[i] + np.array([-1,-1,-1], dtype=float))
        # Correct frac on the fly
        for j in range(3):
            if(np.abs(temp_vec[j]-1.0) &lt; tol):
                temp_vec[j] -= 1.0

        new_frac[i] = temp_vec + np.array(vector, dtype=float)
        #new_frac[i] = np.array(vector, dtype=float)-structure.at_frac[i] + np.array([-1,-1,-1], dtype=float)

    return np.copy(new_frac)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ctoolkit.tools" href="index.html">ctoolkit.tools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ctoolkit.tools.cellOperations.cellOperations" href="#ctoolkit.tools.cellOperations.cellOperations">cellOperations</a></code></h4>
<ul class="">
<li><code><a title="ctoolkit.tools.cellOperations.cellOperations.apply_rotation" href="#ctoolkit.tools.cellOperations.cellOperations.apply_rotation">apply_rotation</a></code></li>
<li><code><a title="ctoolkit.tools.cellOperations.cellOperations.atom_transform" href="#ctoolkit.tools.cellOperations.cellOperations.atom_transform">atom_transform</a></code></li>
<li><code><a title="ctoolkit.tools.cellOperations.cellOperations.build_vectormap" href="#ctoolkit.tools.cellOperations.cellOperations.build_vectormap">build_vectormap</a></code></li>
<li><code><a title="ctoolkit.tools.cellOperations.cellOperations.cart_to_frac" href="#ctoolkit.tools.cellOperations.cellOperations.cart_to_frac">cart_to_frac</a></code></li>
<li><code><a title="ctoolkit.tools.cellOperations.cellOperations.centrosymmetric_supercell" href="#ctoolkit.tools.cellOperations.cellOperations.centrosymmetric_supercell">centrosymmetric_supercell</a></code></li>
<li><code><a title="ctoolkit.tools.cellOperations.cellOperations.centrosymmetric_supercell_VASP" href="#ctoolkit.tools.cellOperations.cellOperations.centrosymmetric_supercell_VASP">centrosymmetric_supercell_VASP</a></code></li>
<li><code><a title="ctoolkit.tools.cellOperations.cellOperations.compute_angles_MD" href="#ctoolkit.tools.cellOperations.cellOperations.compute_angles_MD">compute_angles_MD</a></code></li>
<li><code><a title="ctoolkit.tools.cellOperations.cellOperations.compute_angles_MD_GPT" href="#ctoolkit.tools.cellOperations.cellOperations.compute_angles_MD_GPT">compute_angles_MD_GPT</a></code></li>
<li><code><a title="ctoolkit.tools.cellOperations.cellOperations.findBestPairPeriodic" href="#ctoolkit.tools.cellOperations.cellOperations.findBestPairPeriodic">findBestPairPeriodic</a></code></li>
<li><code><a title="ctoolkit.tools.cellOperations.cellOperations.findBestPairPeriodic_GPT" href="#ctoolkit.tools.cellOperations.cellOperations.findBestPairPeriodic_GPT">findBestPairPeriodic_GPT</a></code></li>
<li><code><a title="ctoolkit.tools.cellOperations.cellOperations.findBestPairPeriodic_test" href="#ctoolkit.tools.cellOperations.cellOperations.findBestPairPeriodic_test">findBestPairPeriodic_test</a></code></li>
<li><code><a title="ctoolkit.tools.cellOperations.cellOperations.find_firstneighbors" href="#ctoolkit.tools.cellOperations.cellOperations.find_firstneighbors">find_firstneighbors</a></code></li>
<li><code><a title="ctoolkit.tools.cellOperations.cellOperations.find_full_molecules" href="#ctoolkit.tools.cellOperations.cellOperations.find_full_molecules">find_full_molecules</a></code></li>
<li><code><a title="ctoolkit.tools.cellOperations.cellOperations.find_groups" href="#ctoolkit.tools.cellOperations.cellOperations.find_groups">find_groups</a></code></li>
<li><code><a title="ctoolkit.tools.cellOperations.cellOperations.find_pairs" href="#ctoolkit.tools.cellOperations.cellOperations.find_pairs">find_pairs</a></code></li>
<li><code><a title="ctoolkit.tools.cellOperations.cellOperations.frac_to_cart" href="#ctoolkit.tools.cellOperations.cellOperations.frac_to_cart">frac_to_cart</a></code></li>
<li><code><a title="ctoolkit.tools.cellOperations.cellOperations.func3" href="#ctoolkit.tools.cellOperations.cellOperations.func3">func3</a></code></li>
<li><code><a title="ctoolkit.tools.cellOperations.cellOperations.handle_periodic_boundaries" href="#ctoolkit.tools.cellOperations.cellOperations.handle_periodic_boundaries">handle_periodic_boundaries</a></code></li>
<li><code><a title="ctoolkit.tools.cellOperations.cellOperations.interpolate_structures" href="#ctoolkit.tools.cellOperations.cellOperations.interpolate_structures">interpolate_structures</a></code></li>
<li><code><a title="ctoolkit.tools.cellOperations.cellOperations.interpolate_structures_VASP" href="#ctoolkit.tools.cellOperations.cellOperations.interpolate_structures_VASP">interpolate_structures_VASP</a></code></li>
<li><code><a title="ctoolkit.tools.cellOperations.cellOperations.new_supercell" href="#ctoolkit.tools.cellOperations.cellOperations.new_supercell">new_supercell</a></code></li>
<li><code><a title="ctoolkit.tools.cellOperations.cellOperations.new_supercell_VASP" href="#ctoolkit.tools.cellOperations.cellOperations.new_supercell_VASP">new_supercell_VASP</a></code></li>
<li><code><a title="ctoolkit.tools.cellOperations.cellOperations.refresh_key" href="#ctoolkit.tools.cellOperations.cellOperations.refresh_key">refresh_key</a></code></li>
<li><code><a title="ctoolkit.tools.cellOperations.cellOperations.rigid_displacement" href="#ctoolkit.tools.cellOperations.cellOperations.rigid_displacement">rigid_displacement</a></code></li>
<li><code><a title="ctoolkit.tools.cellOperations.cellOperations.rigid_rotation" href="#ctoolkit.tools.cellOperations.cellOperations.rigid_rotation">rigid_rotation</a></code></li>
<li><code><a title="ctoolkit.tools.cellOperations.cellOperations.spawn_cell_frac" href="#ctoolkit.tools.cellOperations.cellOperations.spawn_cell_frac">spawn_cell_frac</a></code></li>
<li><code><a title="ctoolkit.tools.cellOperations.cellOperations.spawn_cell_invfrac" href="#ctoolkit.tools.cellOperations.cellOperations.spawn_cell_invfrac">spawn_cell_invfrac</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>