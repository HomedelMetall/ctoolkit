<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ctoolkit.tools.physicalProperties API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ctoolkit.tools.physicalProperties</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from toolkit.global_vars.ext_libs import *

class physicalProperties:
    def __init__(self):
        pass

    def angular_velocities_MD_eig(self, n_vecs, dt):
        # We need error handling in this function
        old_err = np.seterr(all=&#39;raise&#39;)

        w = np.zeros([len(n_vecs), len(n_vecs[0]), 3], dtype=float)
        print(&#34;Processing angular velocities...&#34;)

        for step in range(0, len(n_vecs)-1):
            for i in range(len(n_vecs[0])):
                # u, v = n_vecs[step, i], n_vecs[step+1,i]
                u, v = n_vecs[step, i], n_vecs[step+1, i]

                # We consider here the usual derivative averaging
                # in this new context
                w[step, i] = np.cross(u, v)

                # It needs to be normalized
                # But if it&#39;s zero, it&#39;s zero...
                norm = np.sqrt(np.dot(w[step, i], w[step, i]))
                if not norm &lt; 1E-7:
                    w[step, i] /= np.sqrt(np.dot(w[step, i], w[step, i]))

                # Now we compute w. To do this, we compute the angle
                # between the vectors and how it changes, as if
                # we were sitting in a 2D plane.

                #u, v = n_vecs[step-1, i], n_vecs[step+1,i]

                scalar = np.dot(v,u)
                if scalar &gt; 1.0:
                    theta=np.arccos(1.0)
                else:
                    theta = np.arccos( np.dot(u, v) )#/ (np.sqrt(np.dot(v, v))*np.sqrt(np.dot(u,u))) )

                # We calculate the derivative of the angle to obtain the norm of the angular velocity
                # and apply it to the w vector, taking into account we measure all by
                # double timesteps. Note also that theta= delta theta.
                w[step, i] *= theta/(dt)
            sys.stdout.write(&#34;%3.2f...\r&#34; % (100.*(float(step+1))/(len(n_vecs))))
            sys.stdout.flush()

        # We finally treat the boundary cases
        for i in range(len(n_vecs[0])):
            u, v = n_vecs[-1, i], n_vecs[-2, i]
            w[-1, i] = np.cross(u, v)
            norm = np.sqrt(np.dot(w[-1, i], w[-1, i]))
            if not norm &lt; 1E-7:
                w[-1, i] /= np.sqrt(np.dot(w[-1, i], w[-1, i]))

            scalar = np.dot(u,v)
            if scalar &gt; 1.0:
                theta = np.arccos( 1.0 )# / (np.sqrt(np.dot(v, v))*np.sqrt(np.dot(u, u))) )
            else:
                theta = np.arccos( np.dot(u,v) )

            w[-1, i] *= -theta/(dt)

        np.seterr(**old_err)

        return w

    # A function that computes the derivative per step
    # As is, it computes the rotation angle as the crossproduct
    # of two consecutive velocity vectors.
    def angular_velocities_MD_test(self, n_vecs, dt):
        # We need error handling in this function
        old_err = np.seterr(all=&#39;raise&#39;)

        w = np.zeros([len(n_vecs), len(n_vecs[0]), 3], dtype=float)
        print(&#34;Processing angular velocities...&#34;)

        for step in range(1, len(n_vecs)-1):
            for i in range(len(n_vecs[0])):
                # u, v = n_vecs[step, i], n_vecs[step+1,i]
                u, v = n_vecs[step, i]-n_vecs[step-1, i], n_vecs[step+1, i]-n_vecs[step,i]

                # We consider here the usual derivative averaging
                # in this new context
                w[step, i] = np.cross(u, v)

                # It needs to be normalized
                # But if it&#39;s zero, it&#39;s zero...
                norm = np.sqrt(np.dot(w[step, i], w[step, i]))
                if not norm &lt; 1E-7:
                    w[step, i] /= np.sqrt(np.dot(w[step, i], w[step, i]))

                # Now we compute w. To do this, we compute the angle
                # between the vectors and how it changes, as if
                # we were sitting in a 2D plane.
                
                u, v = n_vecs[step-1, i], n_vecs[step+1,i]

                scalar = np.dot(v,u)
                if scalar &gt; 1.0:
                    theta=np.arccos(1.0)
                else:
                    theta = np.arccos( np.dot(u, v) )#/ (np.sqrt(np.dot(v, v))*np.sqrt(np.dot(u,u))) )

                # We calculate the derivative of the angle to obtain the norm of the angular velocity
                # and apply it to the w vector, taking into account we measure all by
                # double timesteps. Note also that theta= delta theta.
                w[step, i] *= theta/(2*dt)
            sys.stdout.write(&#34;%3.2f...\r&#34; % (100.*(float(step+1))/(len(n_vecs))))
            sys.stdout.flush()

        &#34;&#34;&#34;
        # We finally treat the boundary cases
        for i in range(len(n_vecs[0])):
            u, v = n_vecs[-1, i], n_vecs[-2, i]
            w[-1, i] = np.cross(u, v)
            norm = np.sqrt(np.dot(w[-1, i], w[-1, i]))
            if not norm &lt; 1E-7:
                w[-1, i] /= np.sqrt(np.dot(w[-1, i], w[-1, i]))

            scalar = np.dot(u,v)
            if scalar &gt; 1.0:
                theta = np.arccos( 1.0 )# / (np.sqrt(np.dot(v, v))*np.sqrt(np.dot(u, u))) )
            else:
                theta = np.arccos( np.dot(u,v) )

            w[-1, i] *= -theta/(dt)
        &#34;&#34;&#34;

        np.seterr(**old_err)

        return w[1:-1]

    @calculate_time
    def angular_velocities_MD_GPT(self, n_vecs, dt):
        w = np.zeros([len(n_vecs), len(n_vecs[0]), 3], dtype=float)
        for step in range(1, len(n_vecs)-1):
            u, v = n_vecs[step-1], n_vecs[step+1]
            # we use the numpy cross function to compute cross product 
            # and divide by 2*dt to get the angular velocity
            w[step] = np.cross(u, v) / (2*dt)
        w[0] = w[-1] = w[1] - w[-2]
        return w

    # Calculate angle velocities from the angle description of the system.
    @calculate_time
    def angular_velocities_MD(self, n_vecs, dt):
        # We need error handling in this function
        old_err = np.seterr(all=&#39;raise&#39;)

        # First we compute the vectorial character of the angular velocity
        # That is, we need to find the vector describing the axis of the rotation.
        # Problem is all this is going to be super slow so I&#39;m gonna try to add some
        # descriptors for the time being.
        w = np.zeros([len(n_vecs), len(n_vecs[0]), 3], dtype=float)
        print(&#34;Processing angular velocities...&#34;)
        for step in range(1, len(n_vecs)-1):
            for i in range(len(n_vecs[0])):
                u, v = n_vecs[step-1, i], n_vecs[step+1,i]
                # We consider here the usual derivative averaging
                # in this new context
                w[step, i] = np.cross(u, v)
                
                # It needs to be normalized
                try:
                    w[step, i] /= np.sqrt(np.dot(w[step, i], w[step, i]))
                except:
                    pass

                # Now we compute w. To do this, we compute the angle
                # between the vectors and how it changes, as if 
                # we were sitting in a 2D plane.
                try:
                    theta = np.arccos( np.dot(v, u) / (np.sqrt(np.dot(v, v))*np.sqrt(np.dot(u,u))) )
                except:
                    theta = np.arccos(1.0)

                # We calculate the derivative of the angle to obtain the norm of the angular velocity
                # and apply it to the w vector, taking into account we measure all by
                # double timesteps. Note also that theta= delta theta.
                w[step, i] *= theta/(2*dt)
            sys.stdout.write(&#34;%3.2f...\r&#34; % (100.*(float(step+1))/(len(n_vecs))))
            sys.stdout.flush()

        # We finally treat the boundary cases
        for i in range(len(n_vecs[0])):
            u, v = n_vecs[1, i], n_vecs[0, i]
            w[0, i] = np.cross(u, v)

            try:
                w[0, i] /= np.sqrt(np.dot(w[0, i], w[0, i]))
            except:
                pass

            try:
                theta = np.arccos( np.dot(v, u) / (np.sqrt(np.dot(v, v))*np.sqrt(np.dot(u,u))) )
            except:
                theta = np.arccos(1.0)
            w[0, i] *= -theta/(dt)
        
        for i in range(len(n_vecs[0])):
            u, v = n_vecs[-1, i], n_vecs[-2, i]
            w[-1, i] = np.cross(u, v)
            try:
                w[-1, i] /= np.sqrt(np.dot(w[-1, i], w[-1, i]))
            except:
                pass

            try:
                theta = np.arccos( np.dot(v, u) / (np.sqrt(np.dot(v, v))*np.sqrt(np.dot(u,u))) )
            except:
                theta = np.arccos(1.0)
            w[-1, i] *= -theta/(dt)

        np.seterr(**old_err)

        return w


    def angular_velocities_MD_deprecated(self, angles, dt):
        angular_velocities = np.copy(angles)
        angular_velocities[0] = (angles[1] - angles[0])/dt
        angular_velocities[-1] = (angles[-1] - angles[-2])/dt
   
        post = np.copy(angles[2:])
        pre = np.copy(angles[:-2])
        angular_velocities[1:-1] = (post-pre)/(2*dt)

        #for i in range(1,len(angles)-1):
        #    angular_velocities[i] = (angles[i+1] - angles[i-1])/(2*dt)

        return angular_velocities

    @calculate_time
    def calculate_angle_full(self, v1, v2, e_crossproduct):
        cosphi = np.inner(v1, v2) / (np.linalg.norm(v1)*np.linalg.norm(v2))
        sinphi = np.dot(e_crossproduct, np.cross(v1,v2))
        angle = 180*np.arccos(cosphi)/np.pi
        if sinphi&gt;0:
            return angle
        else:
            return 360-angle

    # e_crossproduct is the e vector normal to the plane v
    # We could compute this internally but then we would need
    # to know which vector projects into which vector, v1, into v2.
    @calculate_time
    def calculate_angle_full_original(self, v1, v2, e_crossproduct):
        cosphi = np.dot(v1, v2)
        sinphi = np.dot(e_crossproduct, np.cross(v1, v2))
        acos = 180*np.arccos(cosphi)/np.pi
        if sinphi &gt;= 0.:
            angle = acos
        else: 
            #sinphi &lt; 0.:
            angle = 180+(180-acos)
        return angle

    @calculate_time
    def calculate_angle(self, v1, v2):
        angle = np.arccos(np.dot(v1, v2)/np.sqrt(np.dot(v1, v1)*np.dot(v2, v2))) 
        return angle

    @calculate_time
    def calculate_polarization(self, born_charges, ref_struct, final_struct):
        displacements = np.copy(final_struct.at_cart - self.frac_to_cart(final_struct.B, ref_struct.at_frac)) # Any cell basis! :)

        P = np.zeros([3])
        for alpha in range(3):
            for atom in range(len(born_charges)): # this could be also final_struct.at_frac
                for beta in range(3):
                    P[alpha] += (born_charges[atom, beta, alpha]*displacements[atom, beta]) / final_struct.volume

        # Conversion factors
        EtoC = 1.6021766E-19
        AtoM = 1.0E-20
        
        P *= EtoC*(1.0E6)/(AtoM*10000.0)
        print(&#34;Polarization (uC/cm^2): %.8f %.8f %.8f&#34; %(P[0], P[1], P[2]))
        print(&#34;Modulus (uC/cm^2): %.8f&#34; % (np.sqrt(np.dot(P, P))))

        return P

    # ATTENTION: we assume SCALEUP formalism, in which cells *are* defined.
    @calculate_time
    def calculate_polarization_direction(self, born_charges, ref_struct, final_struct):
        # Conversion factors
        EtoC = 1.6021766E-19
        AtoM = 1.0E-20

        # Get displacements from RS
        displacements = np.copy(final_struct.at_cart - self.frac_to_cart(final_struct.B, ref_struct.at_frac)) # Any cell basis! :)
        
        # Get cell ordering
        #C[i,j,k]-&gt;displacements[atom, beta] &lt;- ordering
        C = np.copy(ref_struct.cell_id)

        # Get polarization of each cell
        nx, ny, nz = len(C), len(C[0]), len(C[0,0]) # Not sure it works?
        Px = np.zeros([nx, 3], dtype=float)
        Py = np.zeros([ny, 3], dtype=float)
        Pz = np.zeros([nz, 3], dtype=float)
        P = np.zeros([len(C), len(C[0]), len(C[0,0]), 3], dtype=float)
        for i in range(nx):
            for j in range(ny):
                for k in range(nz):
                    # Redefine displacements into disp &lt;- according to C[i,j,k]
                    for alpha in range(3):
                        for atom in range(len(born_charges)): # here we have to go to 5 atoms cell?
                            for beta in range(3):
                                P[i,j,k,alpha] += (born_charges[atom, beta, alpha]*displacement[atom, beta]) / (final_struct.volume/(nx*ny*nz))

        # Unit conversion
        P *= EtoC*(1.0E6)/(AtoM*10000.0)

        # Get polarization per direction
        for i in range(nx):                       
            for j in range(ny):
                for k in range(nz):
                    Px[i] += P[i,j,k]
                    Py[j] += P[i,j,k]
                    Pz[k] += P[i,j,k]

        self.print_to_file(&#39;P_along_x.dat&#39;, [Px])
        self.print_to_file(&#39;P_along_y.dat&#39;, [Py])
        self.print_to_file(&#39;P_along_z.dat&#39;, [Pz])

    @calculate_time
    def BMprime(self, V, e0,v0,k,ep): 

        return (160.217646)* (1.5* v0 * k)* ( (1.0+ 2.0*ep)*(v0/V)**(4.0/3.0)*(1.0/V) - (ep*(v0/V)**(2.0)*(1.0/V)) - (1.0 + ep)*(v0/V)**(2.0/3.0)*(1.0/V) )

    @calculate_time
    def BM(self, V, e0,v0,k,ep):

        return e0 + (1.5 * v0 * k) * ( 0.75*(1.0 + (2.0*ep)) * (v0/V)**(4.0/3.0) - (0.5*ep)*(v0/V)**2.0 - 1.5*(1.0 + ep)*(v0/V)**(2.0/3.0) + 0.5*(ep + 1.5) )

    @calculate_time
    def GF(self, init_params, VE):
        GFvalue = 0.0
        [e0,v0,k,ep] = init_params
        for i in range(len(VE)):
            GFvalue += (VE[i,1]-self.BM(VE[i,0], e0, v0, k, ep))**2/len(VE)
        return GFvalue

    @calculate_time
    def fit_BM(self, V, E):
        from scipy import optimize
        init_params = [-59, 156, 1.34, 1.1]
        VE = np.zeros([len(V),2], dtype=float)
        for i in range(len(V)):
            VE[i,0] = V[i]+0.0
            VE[i,1] = E[i]+0.0

        result1 =  optimize.minimize(self.GF, init_params, args=(VE))[&#39;x&#39;]
        return optimize.minimize(self.GF, result1, args=(VE))

    @calculate_time
    def PV_range(self, range_V, BMparams, filename=None):
        if filename is None: filename = &#39;PV.dat&#39;
        fopen = open(filename, &#39;w&#39;)
        s = &#39;#V(Angstrom**3)\tP(GPa)\n&#39;
        numpoints = 100
        for i in range(numpoints+1):
            V = range_V[0] + (float(i)/float(numpoints))*(range_V[1]-range_V[0])
            P = self.BMprime(V, BMparams[0], BMparams[1], BMparams[2], BMparams[3])
            s += &#39;%.8e\t%.8e\n&#39; % (V, P)
        fopen.write(s)
        fopen.close()    

    @calculate_time
    def EV_range(self, range_V, BMparams, filename=None):
        if filename is None: filename = &#39;EV.dat&#39;
        fopen = open(filename, &#39;w&#39;)
        s = &#39;#V(Angstrom**3)\tE(eV)\n&#39;
        numpoints = 100
        for i in range(numpoints+1):
            V = range_V[0] + (float(i)/float(numpoints))*(range_V[1]-range_V[0])
            E = self.BM(V, BMparams[0], BMparams[1], BMparams[2], BMparams[3])
            s += &#39;%.8e\t%.8e\n&#39; % (V, E)
        fopen.write(s)
        fopen.close()

    # It is prepared to call as process_EV([VASP1.outcar, VASP2.outcar, ...])
    @calculate_time
    def process_EV(self, V, E):
        E_array = np.array(E, dtype=float)
        V_array = np.array(V, dtype=float)

        fit_result = self.fit_BM(V_array, E_array)
        # Process fit
        BMparams = np.copy(fit_result[&#39;x&#39;])
        testparams = [-59.6209, 157.55, 0.0829353, 0.344118]
        self.EV_range([np.min(V_array), np.max(V_array)], BMparams, &#39;EV_fit.dat&#39;)
        self.PV_range([np.min(V_array), np.max(V_array)], BMparams, &#39;PV_fit.dat&#39;)

        fopen = open(&#39;EV_raw.dat&#39;, &#39;w&#39;)
        s = &#39;#V (Angstrom**3)\tE(eV)\n&#39;
        for i in range(len(V)):
            s += &#39;%.8e\t%.8e\n&#39; % (V[i], E[i])
        fopen.write(s)

        return BMparams

    @calculate_time
    def solve_VP(self, final_pressure, BMparams, verbose=False):
        FP = final_pressure
        [e0, v0, k, ep] = BMparams
        tol = 1E-7

        # First sample
        P = 0
        for i in range(1, 2000):
            last_step = FP-P
            P = self.BMprime(float(i), e0, v0, k, ep)+0.0
            this_step = FP - P
        
            if(last_step&lt;0.0 and this_step&gt;0.0):
                init_range = [float(i-1), float(i)]

        Pdiff = 1.0
        [V1, V2] = init_range
        steps = 0
        while(Pdiff&gt;tol):
            new_volume = (V1+V2)/2
            P = self.BMprime(new_volume, e0, v0, k, ep)
            if P &lt; final_pressure:
                [V1, V2] = [V1, new_volume]
            if P &gt; final_pressure:
                [V1, V2] = [new_volume, V2]
            steps += 1
            Pdiff = np.abs(P-FP)

        if verbose: print(&#34;Volume(Angstrom**3) and pressure(GPa) (%dsteps):&#34;%(steps), new_volume, P)
        return new_volume

    @calculate_time
    def Fvib_from_PDOS(self, omegaTHZ, fft, T):
        # Frequency in omega is expected in THz
        kB = 8.617333262E-5 #eV*K^-1
        h = 4.135667696E-15 # eV*s
        omega = 1E12*omegaTHZ
        integrand = np.zeros([int(len(omega))])
        integrand_sinh = np.zeros([int(len(omega))])
        for i in range(1, int(len(omega))):
            integrand[i] = fft[i]*(kB*T*np.log(1.0-np.exp(-(h*omega[i])/(kB*T)))+h*omega[i]/2.0) # VERSION         1
            integrand_sinh[i] = kB*T*(fft[i]*np.log(2.*np.sinh(h*omega[i]/(2.*kB*T))))

        #print(omega,fft)
        F = self.func_integral(omega, integrand_sinh)
        #print(F)
        return F

    # Direct extract of G from PDOS
    @calculate_time
    def S_from_PDOS(self, omegaTHZ, fft, T):
        # Frequency in omega is expected in THz
        kB = 8.617333262E-5 #eV*K^-1
        h = 4.135667696E-15 # eV*s
        omega = 1E12*omegaTHZ
        integrand = np.zeros([int(len(omega))])
        for i in range(1, int(len(omega))):
            argument = h*omega[i]/(2.*kB*T)
            
            integrand[i] = fft[i]*(kB*np.log(2*np.sinh(argument)) - (h*omega[i]*(np.cosh(argument)/np.sinh(argument)))/(2*T))

        S = self.func_integral(omega, integrand)

        return S

    @calculate_time
    def S_from_2Dhist(self, xedges, yedges, hist):
        S = .0
        # There is no kbar...
        old_err = np.seterr(all=&#39;raise&#39;)
        np.seterr(all = &#39;raise&#39;)
        number_of_bins = len(hist)*len(hist[0])
        norm_hist = np.copy(hist)
        xlen = xedges[-1] - xedges[0]
        ylen = yedges[-1] - yedges[0]
        area_element = xlen*ylen/number_of_bins
        for i in range(len(norm_hist)):
            for j in range(len(norm_hist[i])):
                try:
                    S += area_element*norm_hist[i,j]*np.log(area_element*norm_hist[i,j])
                except:
                    continue

        np.seterr(**old_err)
        S = S - np.log(number_of_bins)
        return S

    @calculate_time
    def C_from_PDOS(self, omega, fft, T):
        kB = 8.617333262E-5 #eV*K^-1
        hbar = 6.582119569E-16 # eV*s
        integrand = np.zeros([int(len(omega))])
        for i in range(1, int(len(omega))):
            argument = hbar*1.0E12*omega[i]/(kB*T)

            integrand[i] = fft[i]*kB*(argument**2)*(np.exp(argument)/((np.exp(argument)-1)**2))

        C = self.func_integral(1E12*omega, integrand)

        return C

    @calculate_time
    def G_from_Fvib(self, Fvib, EP, press, vol):
        # Assumes the input units are coherent... :)
        G = EP + Fvib + (press*vol)
        return G

    # Just a wrapper for np.fit
    @calculate_time
    def fit_func(self, f, xdata, ydata):
        popt, pcov = optimize.curve_fit(f, xdata, ydata)
        return popt

    @calculate_time
    def func_integral(self, x, y):
        return np.trapz(y, x)

    @calculate_time
    def func_interpol(self, x, y):
        # We multiply by N the number of points
        n = 10
        new_x = np.zeros([(len(x)-1)*n], dtype=float)
        for i in range(len(x)-1):
            for j in range(n):
                new_x[j+n*i] = x[i] + (x[i+1]-x[i])*(float(j)/float(n))

        return new_x, np.interp(new_x, x, y)

    @calculate_time
    def func_spline(self, x, y):
        from scipy import interpolate
        # We multiply by 3 the number of points, for example
        n = 5 
        new_x = np.zeros([(len(x)-1)*5], dtype=float)
        for i in range(len(x)-1):
            for j in range(5):
                new_x[j+5*i] = x[i] + (x[i+1]-x[i])*(float(j)/float(n))

        tck = interpolate.splrep(x, y)

        y_spline = interpolate.splev(new_x, tck)

        return new_x, y_spline

    @calculate_time
    def func_derivative(self, x, y):
        from scipy import interpolate
        # We multiply by 3 the number of points, for example
        n = 3
        new_x = np.zeros([(len(x)-1)*3], dtype=float)
        for i in range(len(x)-1):
            for j in range(3):
                new_x[j+3*i] = x[i] + (x[i+1]-x[i])*(float(j)/float(n))

        tck = interpolate.splrep(x, y)

        y_der = interpolate.splev(new_x, tck, der=1)

        return new_x, y_der

    @calculate_time
    def func_derivative_direct(self, x, y):
        dx = np.zeros([len(x)-2], dtype=float)
        for i in range(1,len(x)-2):
            dx[i] = (y[i+1]-y[i]) / (x[i+1]-x[i])
            dx[i] += (y[i]-y[i-1]) / (x[i]-x[i-1])
            dx[i] *= 1/2.

        return x[1:-1], dx

    # ACFunc is the autocorrelation function
    # dt is the spacing at which &lt;v(0)*v(dt)&gt; is computed, in seconds
    # Result omega is in THz, and vacf is unbiased.
    # Returns omega, fft
    @calculate_time
    def PDOS_from_ACF(self, ACF, dt, numatoms, normalize=True):
        N=len(ACF)
        omegalong = np.fft.fftfreq(2*N-1, dt)*1E-12
        PDOSlong = np.abs(np.fft.fft(ACF-np.average(ACF), 2*N-1))

        # Only return the non-negative-omega spectrum
        omega = np.copy(omegalong[:int(len(omegalong)/2)])
        PDOS = np.copy(PDOSlong[:int(len(omegalong)/2)])

        if normalize==True:
            norm = self.func_integral(1.0E12*omega, PDOS)
            normalized_PDOS = 3*numatoms*PDOS/norm
            result_PDOS = np.copy(normalized_PDOS)
        else:
            result_PDOS = np.copy(PDOS)

        return omega, result_PDOS

    @calculate_time
    def autocorrelate_vector(self, X):
        from scipy import signal
        result = signal.correlate(X, X, mode=&#39;full&#39;, method=&#39;fft&#39;)
        return result[int(result.size/2):]

    @calculate_time
    def autocorrelate_peratom(self, window, i, shVacf):
        shVacf[0] += self.autocorrelate_vector(window[:, i, 0])
        shVacf[1] += self.autocorrelate_vector(window[:, i, 1])
        shVacf[2] += self.autocorrelate_vector(window[:, i, 2])

    @calculate_time
    def autocorrelate_window(self, window, shVacf):
        num_atoms = len(window[0])
        for i in range(num_atoms):
            shVacf[0] += self.autocorrelate_vector(window[:, i, 0])
            shVacf[1] += self.autocorrelate_vector(window[:, i, 1])
            shVacf[2] += self.autocorrelate_vector(window[:, i, 2])

    @calculate_time
    def compute_VACF_parallel(self, v_array, num_windows):
        num_steps = len(v_array)
        num_atoms = len(v_array[0])

        # Parallel routine initialization
        manager = multiprocessing.Manager()
        shVacf = manager.list([manager.list([0.0]*int(num_steps/2))]*3)

        nprocs = 16
        parsteps = int(num_windows/nprocs)
        parsteps_left = int(num_windows%nprocs)

        vacf = np.zeros([int(num_steps/2)], dtype=float)
        vacfx = np.zeros([int(num_steps/2)], dtype=float)
        vacfy = np.zeros([int(num_steps/2)], dtype=float)
        vacfz = np.zeros([int(num_steps/2)], dtype=float)
        
        for par in range(parsteps):
            runners = []
            for proc in range(nprocs):
                i_window = int(par*nprocs + proc)
                window = np.copy(v_array[i_window:int(i_window+num_steps/2)])
                Args = (window, shVacf)
                runners.append(multiprocessing.Process(
                        target=self.autocorrelate_window,
                                                  args=Args))

            #Launch processes
            for p in runners:
                p.start()
            for p in runners:
                p.join()
            
        runners = []
        for par in range(parsteps_left):
            i_window = int(par + parsteps*nprocs)
            window = np.copy(v_array[i_window:int(i_window+num_steps/2)])
            Args = (window, shVacf, )
            runners.append(multiprocessing.Process(
                    target=self.autocorrelate_window,
                                                args=Args))
        #Launch processes
        for p in runners:
            p.start()
        for p in runners:
            p.join()

        vacf = np.array(shVacf, dtype=float)
        vacf = np.copy((vacf[0] + vacf[1] + vacf[2])/(3.0*num_windows*num_atoms))

        del shVacf
        manager.shutdown()

        return np.copy(vacf)

    @calculate_time
    def compute_VACF_serial(self, v_array, num_windows):
        num_steps = len(v_array)
        num_atoms = len(v_array[0])

        vacf = np.zeros([int(num_steps/2)], dtype=float)
        vacfx = np.zeros([int(num_steps/2)], dtype=float)
        vacfy = np.zeros([int(num_steps/2)], dtype=float)
        vacfz = np.zeros([int(num_steps/2)], dtype=float)
        for i in range(num_windows):
            sp = int(i*(num_steps/2)/num_windows)
            ep = int(sp + num_steps/2)
            window = np.copy(v_array[sp:ep])

            # Arizona contribution:
            for j in range(num_atoms):
                vacfx += self.autocorrelate_vector(window[:, j, 0])
                vacfy += self.autocorrelate_vector(window[:, j, 1])
                vacfz += self.autocorrelate_vector(window[:, j, 2])

        vacf = np.copy((vacfx + vacfy + vacfz)/(3.0*num_windows*num_atoms))

        return np.copy(vacf)
    
    @calculate_time
    def compute_VACF_direct(self, v_array, num_windows):
        num_steps, num_atoms, _ = v_array.shape
        # compute the VACF for each window
        windows = np.array_split(v_array[:num_steps//2], num_windows)
        vacf = np.sum(np.sum(w[:,:,0]*w[0,:,0]+w[:,:,1]*w[0,:,1]+w[:,:,2]*w[0,:,2], axis=1) for w in windows)
        # normalize the result
        vacf /= (3.0*num_windows*num_atoms)
        return vacf

    # Wrapper for parallelization
    # Inner parallelization: parallellization of the v(0)v(t) product, for several t simultaneously. This is the most efficient.
    # Outer parallelization: parallelize the windows.
    # Serial: no parallellization
    @calculate_time
    def compute_VACF(self,  v_array, num_windows, mode=&#39;direct&#39;):

        if len(v_array)/2 &lt; num_windows:
            print(&#34;The windowing mode requires that you &#34;+ 
                    &#34;have less windows than half the number steps! Aborting.&#34;)
            sys.exit()

        if (mode != &#39;direct&#39;) and (mode != &#39;serial&#39;) and (mode != &#39;parallel&#39;):
            print(&#34;Default VACF calculation mode: serial&#34;)
            mode = &#39;direct&#39;

        if mode == &#39;parallel&#39;:
            result = self.compute_VACF_parallel(v_array, num_windows)
        if mode == &#39;serial&#39;:
            result = self.compute_VACF_serial(v_array, num_windows)
        if mode == &#39;direct&#39;:
            result = self.compute_VACF_direct(v_array, num_windows)

        return result

    # We have to see if np.dot(vec of vecs) is what we want...
    # ... no, it doesn&#39;t. Hello.
    # So what we have now is a self-made RACF calculation that should give the right
    # result whatsoever...
    @calculate_time
    def compute_RACF(self, v_array, num_windows=100, normalize=True):
        num_steps = len(v_array)
        num_vectors = len(v_array[0])
        if normalize == True:
            n_array = self.normalize_vectors_MD(v_array)
        else:
            n_array = np.copy(v_array)

        racf = np.zeros([int(num_steps/2)], dtype=float)
        for i in range(num_windows):
            start = int(i*(num_steps/2)/num_windows)
            window = np.copy(n_array[start:int(start+num_steps/2)])
            for j in range(len(window)):
                racf[j] += np.sum(np.einsum(&#39;...j,...j&#39;, window[0], window[j]))

        return np.copy(racf / (num_windows*num_vectors)) 

    def ACF_2D(self, v_array, num_windows=100):
        num_steps = len(v_array)
        num_vectors = len(v_array[0])

        acf = np.zeros([int(num_steps/2)], dtype=float)
        acf2 = np.copy(acf)
        for i in range(num_windows):
            start = int(i*(num_steps/2)/num_windows)
            window = np.copy(v_array[start:int(start+num_steps/2)])
            for j in range(len(window)):
                acf[j] += np.sum(np.einsum(&#39;...j,...j&#39;, window[0], window[j]))
                for k in range(len(window[i])):
                    acf2[j] += np.dot(window[0,k], window[j,k])

        self.print_to_file(&#39;test_ACF.dat&#39;, [acf])
        self.print_to_file(&#39;test_ACF.dat&#39;, [acf2])
        return np.copy(acf / (num_windows*num_vectors))


    @calculate_time
    def compute_RACF_test(self, v_array, normalize=True):
        num_steps = len(v_array)
        num_vectors = len(v_array[0])
        if normalize == True:
            n_array = self.normalize_vectors_MD(v_array)
        else:
            n_array = np.copy(v_array)

        racf = np.zeros([int(num_steps)], dtype=float)
        norm_ct = np.zeros([int(num_steps)], dtype=float)
        for t1 in range(num_steps):
            for t2 in range(t1, num_steps):
                for k in range(len(n_array[0])):
                    racf[t2-t1] += np.dot(n_array[t1, k], n_array[t2, k])
                    norm_ct[t2-t1] += 1

        for i in range(num_steps):
            racf[i] *= 1./norm_ct[i]

        return np.copy(racf)

    # ... and on the other hand, an Arizona-like function
    # that should also provide a result. To be compared really.
    @calculate_time
    def compute_RACF_serial(self, v_array, num_windows=100, normalize=True):
        num_steps = len(v_array)
        num_vecs = len(v_array[0])
        if normalize == True:
            n_array = self.normalize_vectors_MD(v_array)
        else:
            n_array = np.copy(v_array)

        racf = np.zeros([int(num_steps/2)], dtype=float)
        racfx = np.zeros([int(num_steps/2)], dtype=float)
        racfy = np.zeros([int(num_steps/2)], dtype=float)
        racfz = np.zeros([int(num_steps/2)], dtype=float)
        for i in range(num_windows):
            sp = int(i*(num_steps/2)/num_windows)
            ep = int(sp + num_steps/2)
            window = np.copy(n_array[sp:ep])

            # Arizona contribution:
            for j in range(num_vecs):
                racfx += self.autocorrelate_vector(window[:, j, 0])
                racfy += self.autocorrelate_vector(window[:, j, 1])
                racfz += self.autocorrelate_vector(window[:, j, 2])

        racf = np.copy((racfx + racfy + racfz)/(num_windows*num_vecs))

        return np.copy(racf)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties"><code class="flex name class">
<span>class <span class="ident">physicalProperties</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class physicalProperties:
    def __init__(self):
        pass

    def angular_velocities_MD_eig(self, n_vecs, dt):
        # We need error handling in this function
        old_err = np.seterr(all=&#39;raise&#39;)

        w = np.zeros([len(n_vecs), len(n_vecs[0]), 3], dtype=float)
        print(&#34;Processing angular velocities...&#34;)

        for step in range(0, len(n_vecs)-1):
            for i in range(len(n_vecs[0])):
                # u, v = n_vecs[step, i], n_vecs[step+1,i]
                u, v = n_vecs[step, i], n_vecs[step+1, i]

                # We consider here the usual derivative averaging
                # in this new context
                w[step, i] = np.cross(u, v)

                # It needs to be normalized
                # But if it&#39;s zero, it&#39;s zero...
                norm = np.sqrt(np.dot(w[step, i], w[step, i]))
                if not norm &lt; 1E-7:
                    w[step, i] /= np.sqrt(np.dot(w[step, i], w[step, i]))

                # Now we compute w. To do this, we compute the angle
                # between the vectors and how it changes, as if
                # we were sitting in a 2D plane.

                #u, v = n_vecs[step-1, i], n_vecs[step+1,i]

                scalar = np.dot(v,u)
                if scalar &gt; 1.0:
                    theta=np.arccos(1.0)
                else:
                    theta = np.arccos( np.dot(u, v) )#/ (np.sqrt(np.dot(v, v))*np.sqrt(np.dot(u,u))) )

                # We calculate the derivative of the angle to obtain the norm of the angular velocity
                # and apply it to the w vector, taking into account we measure all by
                # double timesteps. Note also that theta= delta theta.
                w[step, i] *= theta/(dt)
            sys.stdout.write(&#34;%3.2f...\r&#34; % (100.*(float(step+1))/(len(n_vecs))))
            sys.stdout.flush()

        # We finally treat the boundary cases
        for i in range(len(n_vecs[0])):
            u, v = n_vecs[-1, i], n_vecs[-2, i]
            w[-1, i] = np.cross(u, v)
            norm = np.sqrt(np.dot(w[-1, i], w[-1, i]))
            if not norm &lt; 1E-7:
                w[-1, i] /= np.sqrt(np.dot(w[-1, i], w[-1, i]))

            scalar = np.dot(u,v)
            if scalar &gt; 1.0:
                theta = np.arccos( 1.0 )# / (np.sqrt(np.dot(v, v))*np.sqrt(np.dot(u, u))) )
            else:
                theta = np.arccos( np.dot(u,v) )

            w[-1, i] *= -theta/(dt)

        np.seterr(**old_err)

        return w

    # A function that computes the derivative per step
    # As is, it computes the rotation angle as the crossproduct
    # of two consecutive velocity vectors.
    def angular_velocities_MD_test(self, n_vecs, dt):
        # We need error handling in this function
        old_err = np.seterr(all=&#39;raise&#39;)

        w = np.zeros([len(n_vecs), len(n_vecs[0]), 3], dtype=float)
        print(&#34;Processing angular velocities...&#34;)

        for step in range(1, len(n_vecs)-1):
            for i in range(len(n_vecs[0])):
                # u, v = n_vecs[step, i], n_vecs[step+1,i]
                u, v = n_vecs[step, i]-n_vecs[step-1, i], n_vecs[step+1, i]-n_vecs[step,i]

                # We consider here the usual derivative averaging
                # in this new context
                w[step, i] = np.cross(u, v)

                # It needs to be normalized
                # But if it&#39;s zero, it&#39;s zero...
                norm = np.sqrt(np.dot(w[step, i], w[step, i]))
                if not norm &lt; 1E-7:
                    w[step, i] /= np.sqrt(np.dot(w[step, i], w[step, i]))

                # Now we compute w. To do this, we compute the angle
                # between the vectors and how it changes, as if
                # we were sitting in a 2D plane.
                
                u, v = n_vecs[step-1, i], n_vecs[step+1,i]

                scalar = np.dot(v,u)
                if scalar &gt; 1.0:
                    theta=np.arccos(1.0)
                else:
                    theta = np.arccos( np.dot(u, v) )#/ (np.sqrt(np.dot(v, v))*np.sqrt(np.dot(u,u))) )

                # We calculate the derivative of the angle to obtain the norm of the angular velocity
                # and apply it to the w vector, taking into account we measure all by
                # double timesteps. Note also that theta= delta theta.
                w[step, i] *= theta/(2*dt)
            sys.stdout.write(&#34;%3.2f...\r&#34; % (100.*(float(step+1))/(len(n_vecs))))
            sys.stdout.flush()

        &#34;&#34;&#34;
        # We finally treat the boundary cases
        for i in range(len(n_vecs[0])):
            u, v = n_vecs[-1, i], n_vecs[-2, i]
            w[-1, i] = np.cross(u, v)
            norm = np.sqrt(np.dot(w[-1, i], w[-1, i]))
            if not norm &lt; 1E-7:
                w[-1, i] /= np.sqrt(np.dot(w[-1, i], w[-1, i]))

            scalar = np.dot(u,v)
            if scalar &gt; 1.0:
                theta = np.arccos( 1.0 )# / (np.sqrt(np.dot(v, v))*np.sqrt(np.dot(u, u))) )
            else:
                theta = np.arccos( np.dot(u,v) )

            w[-1, i] *= -theta/(dt)
        &#34;&#34;&#34;

        np.seterr(**old_err)

        return w[1:-1]

    @calculate_time
    def angular_velocities_MD_GPT(self, n_vecs, dt):
        w = np.zeros([len(n_vecs), len(n_vecs[0]), 3], dtype=float)
        for step in range(1, len(n_vecs)-1):
            u, v = n_vecs[step-1], n_vecs[step+1]
            # we use the numpy cross function to compute cross product 
            # and divide by 2*dt to get the angular velocity
            w[step] = np.cross(u, v) / (2*dt)
        w[0] = w[-1] = w[1] - w[-2]
        return w

    # Calculate angle velocities from the angle description of the system.
    @calculate_time
    def angular_velocities_MD(self, n_vecs, dt):
        # We need error handling in this function
        old_err = np.seterr(all=&#39;raise&#39;)

        # First we compute the vectorial character of the angular velocity
        # That is, we need to find the vector describing the axis of the rotation.
        # Problem is all this is going to be super slow so I&#39;m gonna try to add some
        # descriptors for the time being.
        w = np.zeros([len(n_vecs), len(n_vecs[0]), 3], dtype=float)
        print(&#34;Processing angular velocities...&#34;)
        for step in range(1, len(n_vecs)-1):
            for i in range(len(n_vecs[0])):
                u, v = n_vecs[step-1, i], n_vecs[step+1,i]
                # We consider here the usual derivative averaging
                # in this new context
                w[step, i] = np.cross(u, v)
                
                # It needs to be normalized
                try:
                    w[step, i] /= np.sqrt(np.dot(w[step, i], w[step, i]))
                except:
                    pass

                # Now we compute w. To do this, we compute the angle
                # between the vectors and how it changes, as if 
                # we were sitting in a 2D plane.
                try:
                    theta = np.arccos( np.dot(v, u) / (np.sqrt(np.dot(v, v))*np.sqrt(np.dot(u,u))) )
                except:
                    theta = np.arccos(1.0)

                # We calculate the derivative of the angle to obtain the norm of the angular velocity
                # and apply it to the w vector, taking into account we measure all by
                # double timesteps. Note also that theta= delta theta.
                w[step, i] *= theta/(2*dt)
            sys.stdout.write(&#34;%3.2f...\r&#34; % (100.*(float(step+1))/(len(n_vecs))))
            sys.stdout.flush()

        # We finally treat the boundary cases
        for i in range(len(n_vecs[0])):
            u, v = n_vecs[1, i], n_vecs[0, i]
            w[0, i] = np.cross(u, v)

            try:
                w[0, i] /= np.sqrt(np.dot(w[0, i], w[0, i]))
            except:
                pass

            try:
                theta = np.arccos( np.dot(v, u) / (np.sqrt(np.dot(v, v))*np.sqrt(np.dot(u,u))) )
            except:
                theta = np.arccos(1.0)
            w[0, i] *= -theta/(dt)
        
        for i in range(len(n_vecs[0])):
            u, v = n_vecs[-1, i], n_vecs[-2, i]
            w[-1, i] = np.cross(u, v)
            try:
                w[-1, i] /= np.sqrt(np.dot(w[-1, i], w[-1, i]))
            except:
                pass

            try:
                theta = np.arccos( np.dot(v, u) / (np.sqrt(np.dot(v, v))*np.sqrt(np.dot(u,u))) )
            except:
                theta = np.arccos(1.0)
            w[-1, i] *= -theta/(dt)

        np.seterr(**old_err)

        return w


    def angular_velocities_MD_deprecated(self, angles, dt):
        angular_velocities = np.copy(angles)
        angular_velocities[0] = (angles[1] - angles[0])/dt
        angular_velocities[-1] = (angles[-1] - angles[-2])/dt
   
        post = np.copy(angles[2:])
        pre = np.copy(angles[:-2])
        angular_velocities[1:-1] = (post-pre)/(2*dt)

        #for i in range(1,len(angles)-1):
        #    angular_velocities[i] = (angles[i+1] - angles[i-1])/(2*dt)

        return angular_velocities

    @calculate_time
    def calculate_angle_full(self, v1, v2, e_crossproduct):
        cosphi = np.inner(v1, v2) / (np.linalg.norm(v1)*np.linalg.norm(v2))
        sinphi = np.dot(e_crossproduct, np.cross(v1,v2))
        angle = 180*np.arccos(cosphi)/np.pi
        if sinphi&gt;0:
            return angle
        else:
            return 360-angle

    # e_crossproduct is the e vector normal to the plane v
    # We could compute this internally but then we would need
    # to know which vector projects into which vector, v1, into v2.
    @calculate_time
    def calculate_angle_full_original(self, v1, v2, e_crossproduct):
        cosphi = np.dot(v1, v2)
        sinphi = np.dot(e_crossproduct, np.cross(v1, v2))
        acos = 180*np.arccos(cosphi)/np.pi
        if sinphi &gt;= 0.:
            angle = acos
        else: 
            #sinphi &lt; 0.:
            angle = 180+(180-acos)
        return angle

    @calculate_time
    def calculate_angle(self, v1, v2):
        angle = np.arccos(np.dot(v1, v2)/np.sqrt(np.dot(v1, v1)*np.dot(v2, v2))) 
        return angle

    @calculate_time
    def calculate_polarization(self, born_charges, ref_struct, final_struct):
        displacements = np.copy(final_struct.at_cart - self.frac_to_cart(final_struct.B, ref_struct.at_frac)) # Any cell basis! :)

        P = np.zeros([3])
        for alpha in range(3):
            for atom in range(len(born_charges)): # this could be also final_struct.at_frac
                for beta in range(3):
                    P[alpha] += (born_charges[atom, beta, alpha]*displacements[atom, beta]) / final_struct.volume

        # Conversion factors
        EtoC = 1.6021766E-19
        AtoM = 1.0E-20
        
        P *= EtoC*(1.0E6)/(AtoM*10000.0)
        print(&#34;Polarization (uC/cm^2): %.8f %.8f %.8f&#34; %(P[0], P[1], P[2]))
        print(&#34;Modulus (uC/cm^2): %.8f&#34; % (np.sqrt(np.dot(P, P))))

        return P

    # ATTENTION: we assume SCALEUP formalism, in which cells *are* defined.
    @calculate_time
    def calculate_polarization_direction(self, born_charges, ref_struct, final_struct):
        # Conversion factors
        EtoC = 1.6021766E-19
        AtoM = 1.0E-20

        # Get displacements from RS
        displacements = np.copy(final_struct.at_cart - self.frac_to_cart(final_struct.B, ref_struct.at_frac)) # Any cell basis! :)
        
        # Get cell ordering
        #C[i,j,k]-&gt;displacements[atom, beta] &lt;- ordering
        C = np.copy(ref_struct.cell_id)

        # Get polarization of each cell
        nx, ny, nz = len(C), len(C[0]), len(C[0,0]) # Not sure it works?
        Px = np.zeros([nx, 3], dtype=float)
        Py = np.zeros([ny, 3], dtype=float)
        Pz = np.zeros([nz, 3], dtype=float)
        P = np.zeros([len(C), len(C[0]), len(C[0,0]), 3], dtype=float)
        for i in range(nx):
            for j in range(ny):
                for k in range(nz):
                    # Redefine displacements into disp &lt;- according to C[i,j,k]
                    for alpha in range(3):
                        for atom in range(len(born_charges)): # here we have to go to 5 atoms cell?
                            for beta in range(3):
                                P[i,j,k,alpha] += (born_charges[atom, beta, alpha]*displacement[atom, beta]) / (final_struct.volume/(nx*ny*nz))

        # Unit conversion
        P *= EtoC*(1.0E6)/(AtoM*10000.0)

        # Get polarization per direction
        for i in range(nx):                       
            for j in range(ny):
                for k in range(nz):
                    Px[i] += P[i,j,k]
                    Py[j] += P[i,j,k]
                    Pz[k] += P[i,j,k]

        self.print_to_file(&#39;P_along_x.dat&#39;, [Px])
        self.print_to_file(&#39;P_along_y.dat&#39;, [Py])
        self.print_to_file(&#39;P_along_z.dat&#39;, [Pz])

    @calculate_time
    def BMprime(self, V, e0,v0,k,ep): 

        return (160.217646)* (1.5* v0 * k)* ( (1.0+ 2.0*ep)*(v0/V)**(4.0/3.0)*(1.0/V) - (ep*(v0/V)**(2.0)*(1.0/V)) - (1.0 + ep)*(v0/V)**(2.0/3.0)*(1.0/V) )

    @calculate_time
    def BM(self, V, e0,v0,k,ep):

        return e0 + (1.5 * v0 * k) * ( 0.75*(1.0 + (2.0*ep)) * (v0/V)**(4.0/3.0) - (0.5*ep)*(v0/V)**2.0 - 1.5*(1.0 + ep)*(v0/V)**(2.0/3.0) + 0.5*(ep + 1.5) )

    @calculate_time
    def GF(self, init_params, VE):
        GFvalue = 0.0
        [e0,v0,k,ep] = init_params
        for i in range(len(VE)):
            GFvalue += (VE[i,1]-self.BM(VE[i,0], e0, v0, k, ep))**2/len(VE)
        return GFvalue

    @calculate_time
    def fit_BM(self, V, E):
        from scipy import optimize
        init_params = [-59, 156, 1.34, 1.1]
        VE = np.zeros([len(V),2], dtype=float)
        for i in range(len(V)):
            VE[i,0] = V[i]+0.0
            VE[i,1] = E[i]+0.0

        result1 =  optimize.minimize(self.GF, init_params, args=(VE))[&#39;x&#39;]
        return optimize.minimize(self.GF, result1, args=(VE))

    @calculate_time
    def PV_range(self, range_V, BMparams, filename=None):
        if filename is None: filename = &#39;PV.dat&#39;
        fopen = open(filename, &#39;w&#39;)
        s = &#39;#V(Angstrom**3)\tP(GPa)\n&#39;
        numpoints = 100
        for i in range(numpoints+1):
            V = range_V[0] + (float(i)/float(numpoints))*(range_V[1]-range_V[0])
            P = self.BMprime(V, BMparams[0], BMparams[1], BMparams[2], BMparams[3])
            s += &#39;%.8e\t%.8e\n&#39; % (V, P)
        fopen.write(s)
        fopen.close()    

    @calculate_time
    def EV_range(self, range_V, BMparams, filename=None):
        if filename is None: filename = &#39;EV.dat&#39;
        fopen = open(filename, &#39;w&#39;)
        s = &#39;#V(Angstrom**3)\tE(eV)\n&#39;
        numpoints = 100
        for i in range(numpoints+1):
            V = range_V[0] + (float(i)/float(numpoints))*(range_V[1]-range_V[0])
            E = self.BM(V, BMparams[0], BMparams[1], BMparams[2], BMparams[3])
            s += &#39;%.8e\t%.8e\n&#39; % (V, E)
        fopen.write(s)
        fopen.close()

    # It is prepared to call as process_EV([VASP1.outcar, VASP2.outcar, ...])
    @calculate_time
    def process_EV(self, V, E):
        E_array = np.array(E, dtype=float)
        V_array = np.array(V, dtype=float)

        fit_result = self.fit_BM(V_array, E_array)
        # Process fit
        BMparams = np.copy(fit_result[&#39;x&#39;])
        testparams = [-59.6209, 157.55, 0.0829353, 0.344118]
        self.EV_range([np.min(V_array), np.max(V_array)], BMparams, &#39;EV_fit.dat&#39;)
        self.PV_range([np.min(V_array), np.max(V_array)], BMparams, &#39;PV_fit.dat&#39;)

        fopen = open(&#39;EV_raw.dat&#39;, &#39;w&#39;)
        s = &#39;#V (Angstrom**3)\tE(eV)\n&#39;
        for i in range(len(V)):
            s += &#39;%.8e\t%.8e\n&#39; % (V[i], E[i])
        fopen.write(s)

        return BMparams

    @calculate_time
    def solve_VP(self, final_pressure, BMparams, verbose=False):
        FP = final_pressure
        [e0, v0, k, ep] = BMparams
        tol = 1E-7

        # First sample
        P = 0
        for i in range(1, 2000):
            last_step = FP-P
            P = self.BMprime(float(i), e0, v0, k, ep)+0.0
            this_step = FP - P
        
            if(last_step&lt;0.0 and this_step&gt;0.0):
                init_range = [float(i-1), float(i)]

        Pdiff = 1.0
        [V1, V2] = init_range
        steps = 0
        while(Pdiff&gt;tol):
            new_volume = (V1+V2)/2
            P = self.BMprime(new_volume, e0, v0, k, ep)
            if P &lt; final_pressure:
                [V1, V2] = [V1, new_volume]
            if P &gt; final_pressure:
                [V1, V2] = [new_volume, V2]
            steps += 1
            Pdiff = np.abs(P-FP)

        if verbose: print(&#34;Volume(Angstrom**3) and pressure(GPa) (%dsteps):&#34;%(steps), new_volume, P)
        return new_volume

    @calculate_time
    def Fvib_from_PDOS(self, omegaTHZ, fft, T):
        # Frequency in omega is expected in THz
        kB = 8.617333262E-5 #eV*K^-1
        h = 4.135667696E-15 # eV*s
        omega = 1E12*omegaTHZ
        integrand = np.zeros([int(len(omega))])
        integrand_sinh = np.zeros([int(len(omega))])
        for i in range(1, int(len(omega))):
            integrand[i] = fft[i]*(kB*T*np.log(1.0-np.exp(-(h*omega[i])/(kB*T)))+h*omega[i]/2.0) # VERSION         1
            integrand_sinh[i] = kB*T*(fft[i]*np.log(2.*np.sinh(h*omega[i]/(2.*kB*T))))

        #print(omega,fft)
        F = self.func_integral(omega, integrand_sinh)
        #print(F)
        return F

    # Direct extract of G from PDOS
    @calculate_time
    def S_from_PDOS(self, omegaTHZ, fft, T):
        # Frequency in omega is expected in THz
        kB = 8.617333262E-5 #eV*K^-1
        h = 4.135667696E-15 # eV*s
        omega = 1E12*omegaTHZ
        integrand = np.zeros([int(len(omega))])
        for i in range(1, int(len(omega))):
            argument = h*omega[i]/(2.*kB*T)
            
            integrand[i] = fft[i]*(kB*np.log(2*np.sinh(argument)) - (h*omega[i]*(np.cosh(argument)/np.sinh(argument)))/(2*T))

        S = self.func_integral(omega, integrand)

        return S

    @calculate_time
    def S_from_2Dhist(self, xedges, yedges, hist):
        S = .0
        # There is no kbar...
        old_err = np.seterr(all=&#39;raise&#39;)
        np.seterr(all = &#39;raise&#39;)
        number_of_bins = len(hist)*len(hist[0])
        norm_hist = np.copy(hist)
        xlen = xedges[-1] - xedges[0]
        ylen = yedges[-1] - yedges[0]
        area_element = xlen*ylen/number_of_bins
        for i in range(len(norm_hist)):
            for j in range(len(norm_hist[i])):
                try:
                    S += area_element*norm_hist[i,j]*np.log(area_element*norm_hist[i,j])
                except:
                    continue

        np.seterr(**old_err)
        S = S - np.log(number_of_bins)
        return S

    @calculate_time
    def C_from_PDOS(self, omega, fft, T):
        kB = 8.617333262E-5 #eV*K^-1
        hbar = 6.582119569E-16 # eV*s
        integrand = np.zeros([int(len(omega))])
        for i in range(1, int(len(omega))):
            argument = hbar*1.0E12*omega[i]/(kB*T)

            integrand[i] = fft[i]*kB*(argument**2)*(np.exp(argument)/((np.exp(argument)-1)**2))

        C = self.func_integral(1E12*omega, integrand)

        return C

    @calculate_time
    def G_from_Fvib(self, Fvib, EP, press, vol):
        # Assumes the input units are coherent... :)
        G = EP + Fvib + (press*vol)
        return G

    # Just a wrapper for np.fit
    @calculate_time
    def fit_func(self, f, xdata, ydata):
        popt, pcov = optimize.curve_fit(f, xdata, ydata)
        return popt

    @calculate_time
    def func_integral(self, x, y):
        return np.trapz(y, x)

    @calculate_time
    def func_interpol(self, x, y):
        # We multiply by N the number of points
        n = 10
        new_x = np.zeros([(len(x)-1)*n], dtype=float)
        for i in range(len(x)-1):
            for j in range(n):
                new_x[j+n*i] = x[i] + (x[i+1]-x[i])*(float(j)/float(n))

        return new_x, np.interp(new_x, x, y)

    @calculate_time
    def func_spline(self, x, y):
        from scipy import interpolate
        # We multiply by 3 the number of points, for example
        n = 5 
        new_x = np.zeros([(len(x)-1)*5], dtype=float)
        for i in range(len(x)-1):
            for j in range(5):
                new_x[j+5*i] = x[i] + (x[i+1]-x[i])*(float(j)/float(n))

        tck = interpolate.splrep(x, y)

        y_spline = interpolate.splev(new_x, tck)

        return new_x, y_spline

    @calculate_time
    def func_derivative(self, x, y):
        from scipy import interpolate
        # We multiply by 3 the number of points, for example
        n = 3
        new_x = np.zeros([(len(x)-1)*3], dtype=float)
        for i in range(len(x)-1):
            for j in range(3):
                new_x[j+3*i] = x[i] + (x[i+1]-x[i])*(float(j)/float(n))

        tck = interpolate.splrep(x, y)

        y_der = interpolate.splev(new_x, tck, der=1)

        return new_x, y_der

    @calculate_time
    def func_derivative_direct(self, x, y):
        dx = np.zeros([len(x)-2], dtype=float)
        for i in range(1,len(x)-2):
            dx[i] = (y[i+1]-y[i]) / (x[i+1]-x[i])
            dx[i] += (y[i]-y[i-1]) / (x[i]-x[i-1])
            dx[i] *= 1/2.

        return x[1:-1], dx

    # ACFunc is the autocorrelation function
    # dt is the spacing at which &lt;v(0)*v(dt)&gt; is computed, in seconds
    # Result omega is in THz, and vacf is unbiased.
    # Returns omega, fft
    @calculate_time
    def PDOS_from_ACF(self, ACF, dt, numatoms, normalize=True):
        N=len(ACF)
        omegalong = np.fft.fftfreq(2*N-1, dt)*1E-12
        PDOSlong = np.abs(np.fft.fft(ACF-np.average(ACF), 2*N-1))

        # Only return the non-negative-omega spectrum
        omega = np.copy(omegalong[:int(len(omegalong)/2)])
        PDOS = np.copy(PDOSlong[:int(len(omegalong)/2)])

        if normalize==True:
            norm = self.func_integral(1.0E12*omega, PDOS)
            normalized_PDOS = 3*numatoms*PDOS/norm
            result_PDOS = np.copy(normalized_PDOS)
        else:
            result_PDOS = np.copy(PDOS)

        return omega, result_PDOS

    @calculate_time
    def autocorrelate_vector(self, X):
        from scipy import signal
        result = signal.correlate(X, X, mode=&#39;full&#39;, method=&#39;fft&#39;)
        return result[int(result.size/2):]

    @calculate_time
    def autocorrelate_peratom(self, window, i, shVacf):
        shVacf[0] += self.autocorrelate_vector(window[:, i, 0])
        shVacf[1] += self.autocorrelate_vector(window[:, i, 1])
        shVacf[2] += self.autocorrelate_vector(window[:, i, 2])

    @calculate_time
    def autocorrelate_window(self, window, shVacf):
        num_atoms = len(window[0])
        for i in range(num_atoms):
            shVacf[0] += self.autocorrelate_vector(window[:, i, 0])
            shVacf[1] += self.autocorrelate_vector(window[:, i, 1])
            shVacf[2] += self.autocorrelate_vector(window[:, i, 2])

    @calculate_time
    def compute_VACF_parallel(self, v_array, num_windows):
        num_steps = len(v_array)
        num_atoms = len(v_array[0])

        # Parallel routine initialization
        manager = multiprocessing.Manager()
        shVacf = manager.list([manager.list([0.0]*int(num_steps/2))]*3)

        nprocs = 16
        parsteps = int(num_windows/nprocs)
        parsteps_left = int(num_windows%nprocs)

        vacf = np.zeros([int(num_steps/2)], dtype=float)
        vacfx = np.zeros([int(num_steps/2)], dtype=float)
        vacfy = np.zeros([int(num_steps/2)], dtype=float)
        vacfz = np.zeros([int(num_steps/2)], dtype=float)
        
        for par in range(parsteps):
            runners = []
            for proc in range(nprocs):
                i_window = int(par*nprocs + proc)
                window = np.copy(v_array[i_window:int(i_window+num_steps/2)])
                Args = (window, shVacf)
                runners.append(multiprocessing.Process(
                        target=self.autocorrelate_window,
                                                  args=Args))

            #Launch processes
            for p in runners:
                p.start()
            for p in runners:
                p.join()
            
        runners = []
        for par in range(parsteps_left):
            i_window = int(par + parsteps*nprocs)
            window = np.copy(v_array[i_window:int(i_window+num_steps/2)])
            Args = (window, shVacf, )
            runners.append(multiprocessing.Process(
                    target=self.autocorrelate_window,
                                                args=Args))
        #Launch processes
        for p in runners:
            p.start()
        for p in runners:
            p.join()

        vacf = np.array(shVacf, dtype=float)
        vacf = np.copy((vacf[0] + vacf[1] + vacf[2])/(3.0*num_windows*num_atoms))

        del shVacf
        manager.shutdown()

        return np.copy(vacf)

    @calculate_time
    def compute_VACF_serial(self, v_array, num_windows):
        num_steps = len(v_array)
        num_atoms = len(v_array[0])

        vacf = np.zeros([int(num_steps/2)], dtype=float)
        vacfx = np.zeros([int(num_steps/2)], dtype=float)
        vacfy = np.zeros([int(num_steps/2)], dtype=float)
        vacfz = np.zeros([int(num_steps/2)], dtype=float)
        for i in range(num_windows):
            sp = int(i*(num_steps/2)/num_windows)
            ep = int(sp + num_steps/2)
            window = np.copy(v_array[sp:ep])

            # Arizona contribution:
            for j in range(num_atoms):
                vacfx += self.autocorrelate_vector(window[:, j, 0])
                vacfy += self.autocorrelate_vector(window[:, j, 1])
                vacfz += self.autocorrelate_vector(window[:, j, 2])

        vacf = np.copy((vacfx + vacfy + vacfz)/(3.0*num_windows*num_atoms))

        return np.copy(vacf)
    
    @calculate_time
    def compute_VACF_direct(self, v_array, num_windows):
        num_steps, num_atoms, _ = v_array.shape
        # compute the VACF for each window
        windows = np.array_split(v_array[:num_steps//2], num_windows)
        vacf = np.sum(np.sum(w[:,:,0]*w[0,:,0]+w[:,:,1]*w[0,:,1]+w[:,:,2]*w[0,:,2], axis=1) for w in windows)
        # normalize the result
        vacf /= (3.0*num_windows*num_atoms)
        return vacf

    # Wrapper for parallelization
    # Inner parallelization: parallellization of the v(0)v(t) product, for several t simultaneously. This is the most efficient.
    # Outer parallelization: parallelize the windows.
    # Serial: no parallellization
    @calculate_time
    def compute_VACF(self,  v_array, num_windows, mode=&#39;direct&#39;):

        if len(v_array)/2 &lt; num_windows:
            print(&#34;The windowing mode requires that you &#34;+ 
                    &#34;have less windows than half the number steps! Aborting.&#34;)
            sys.exit()

        if (mode != &#39;direct&#39;) and (mode != &#39;serial&#39;) and (mode != &#39;parallel&#39;):
            print(&#34;Default VACF calculation mode: serial&#34;)
            mode = &#39;direct&#39;

        if mode == &#39;parallel&#39;:
            result = self.compute_VACF_parallel(v_array, num_windows)
        if mode == &#39;serial&#39;:
            result = self.compute_VACF_serial(v_array, num_windows)
        if mode == &#39;direct&#39;:
            result = self.compute_VACF_direct(v_array, num_windows)

        return result

    # We have to see if np.dot(vec of vecs) is what we want...
    # ... no, it doesn&#39;t. Hello.
    # So what we have now is a self-made RACF calculation that should give the right
    # result whatsoever...
    @calculate_time
    def compute_RACF(self, v_array, num_windows=100, normalize=True):
        num_steps = len(v_array)
        num_vectors = len(v_array[0])
        if normalize == True:
            n_array = self.normalize_vectors_MD(v_array)
        else:
            n_array = np.copy(v_array)

        racf = np.zeros([int(num_steps/2)], dtype=float)
        for i in range(num_windows):
            start = int(i*(num_steps/2)/num_windows)
            window = np.copy(n_array[start:int(start+num_steps/2)])
            for j in range(len(window)):
                racf[j] += np.sum(np.einsum(&#39;...j,...j&#39;, window[0], window[j]))

        return np.copy(racf / (num_windows*num_vectors)) 

    def ACF_2D(self, v_array, num_windows=100):
        num_steps = len(v_array)
        num_vectors = len(v_array[0])

        acf = np.zeros([int(num_steps/2)], dtype=float)
        acf2 = np.copy(acf)
        for i in range(num_windows):
            start = int(i*(num_steps/2)/num_windows)
            window = np.copy(v_array[start:int(start+num_steps/2)])
            for j in range(len(window)):
                acf[j] += np.sum(np.einsum(&#39;...j,...j&#39;, window[0], window[j]))
                for k in range(len(window[i])):
                    acf2[j] += np.dot(window[0,k], window[j,k])

        self.print_to_file(&#39;test_ACF.dat&#39;, [acf])
        self.print_to_file(&#39;test_ACF.dat&#39;, [acf2])
        return np.copy(acf / (num_windows*num_vectors))


    @calculate_time
    def compute_RACF_test(self, v_array, normalize=True):
        num_steps = len(v_array)
        num_vectors = len(v_array[0])
        if normalize == True:
            n_array = self.normalize_vectors_MD(v_array)
        else:
            n_array = np.copy(v_array)

        racf = np.zeros([int(num_steps)], dtype=float)
        norm_ct = np.zeros([int(num_steps)], dtype=float)
        for t1 in range(num_steps):
            for t2 in range(t1, num_steps):
                for k in range(len(n_array[0])):
                    racf[t2-t1] += np.dot(n_array[t1, k], n_array[t2, k])
                    norm_ct[t2-t1] += 1

        for i in range(num_steps):
            racf[i] *= 1./norm_ct[i]

        return np.copy(racf)

    # ... and on the other hand, an Arizona-like function
    # that should also provide a result. To be compared really.
    @calculate_time
    def compute_RACF_serial(self, v_array, num_windows=100, normalize=True):
        num_steps = len(v_array)
        num_vecs = len(v_array[0])
        if normalize == True:
            n_array = self.normalize_vectors_MD(v_array)
        else:
            n_array = np.copy(v_array)

        racf = np.zeros([int(num_steps/2)], dtype=float)
        racfx = np.zeros([int(num_steps/2)], dtype=float)
        racfy = np.zeros([int(num_steps/2)], dtype=float)
        racfz = np.zeros([int(num_steps/2)], dtype=float)
        for i in range(num_windows):
            sp = int(i*(num_steps/2)/num_windows)
            ep = int(sp + num_steps/2)
            window = np.copy(n_array[sp:ep])

            # Arizona contribution:
            for j in range(num_vecs):
                racfx += self.autocorrelate_vector(window[:, j, 0])
                racfy += self.autocorrelate_vector(window[:, j, 1])
                racfz += self.autocorrelate_vector(window[:, j, 2])

        racf = np.copy((racfx + racfy + racfz)/(num_windows*num_vecs))

        return np.copy(racf)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.ACF_2D"><code class="name flex">
<span>def <span class="ident">ACF_2D</span></span>(<span>self, v_array, num_windows=100)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ACF_2D(self, v_array, num_windows=100):
    num_steps = len(v_array)
    num_vectors = len(v_array[0])

    acf = np.zeros([int(num_steps/2)], dtype=float)
    acf2 = np.copy(acf)
    for i in range(num_windows):
        start = int(i*(num_steps/2)/num_windows)
        window = np.copy(v_array[start:int(start+num_steps/2)])
        for j in range(len(window)):
            acf[j] += np.sum(np.einsum(&#39;...j,...j&#39;, window[0], window[j]))
            for k in range(len(window[i])):
                acf2[j] += np.dot(window[0,k], window[j,k])

    self.print_to_file(&#39;test_ACF.dat&#39;, [acf])
    self.print_to_file(&#39;test_ACF.dat&#39;, [acf2])
    return np.copy(acf / (num_windows*num_vectors))</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.BM"><code class="name flex">
<span>def <span class="ident">BM</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.BMprime"><code class="name flex">
<span>def <span class="ident">BMprime</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.C_from_PDOS"><code class="name flex">
<span>def <span class="ident">C_from_PDOS</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.EV_range"><code class="name flex">
<span>def <span class="ident">EV_range</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.Fvib_from_PDOS"><code class="name flex">
<span>def <span class="ident">Fvib_from_PDOS</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.GF"><code class="name flex">
<span>def <span class="ident">GF</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.G_from_Fvib"><code class="name flex">
<span>def <span class="ident">G_from_Fvib</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.PDOS_from_ACF"><code class="name flex">
<span>def <span class="ident">PDOS_from_ACF</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.PV_range"><code class="name flex">
<span>def <span class="ident">PV_range</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.S_from_2Dhist"><code class="name flex">
<span>def <span class="ident">S_from_2Dhist</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.S_from_PDOS"><code class="name flex">
<span>def <span class="ident">S_from_PDOS</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.angular_velocities_MD"><code class="name flex">
<span>def <span class="ident">angular_velocities_MD</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.angular_velocities_MD_GPT"><code class="name flex">
<span>def <span class="ident">angular_velocities_MD_GPT</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.angular_velocities_MD_deprecated"><code class="name flex">
<span>def <span class="ident">angular_velocities_MD_deprecated</span></span>(<span>self, angles, dt)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def angular_velocities_MD_deprecated(self, angles, dt):
    angular_velocities = np.copy(angles)
    angular_velocities[0] = (angles[1] - angles[0])/dt
    angular_velocities[-1] = (angles[-1] - angles[-2])/dt

    post = np.copy(angles[2:])
    pre = np.copy(angles[:-2])
    angular_velocities[1:-1] = (post-pre)/(2*dt)

    #for i in range(1,len(angles)-1):
    #    angular_velocities[i] = (angles[i+1] - angles[i-1])/(2*dt)

    return angular_velocities</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.angular_velocities_MD_eig"><code class="name flex">
<span>def <span class="ident">angular_velocities_MD_eig</span></span>(<span>self, n_vecs, dt)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def angular_velocities_MD_eig(self, n_vecs, dt):
    # We need error handling in this function
    old_err = np.seterr(all=&#39;raise&#39;)

    w = np.zeros([len(n_vecs), len(n_vecs[0]), 3], dtype=float)
    print(&#34;Processing angular velocities...&#34;)

    for step in range(0, len(n_vecs)-1):
        for i in range(len(n_vecs[0])):
            # u, v = n_vecs[step, i], n_vecs[step+1,i]
            u, v = n_vecs[step, i], n_vecs[step+1, i]

            # We consider here the usual derivative averaging
            # in this new context
            w[step, i] = np.cross(u, v)

            # It needs to be normalized
            # But if it&#39;s zero, it&#39;s zero...
            norm = np.sqrt(np.dot(w[step, i], w[step, i]))
            if not norm &lt; 1E-7:
                w[step, i] /= np.sqrt(np.dot(w[step, i], w[step, i]))

            # Now we compute w. To do this, we compute the angle
            # between the vectors and how it changes, as if
            # we were sitting in a 2D plane.

            #u, v = n_vecs[step-1, i], n_vecs[step+1,i]

            scalar = np.dot(v,u)
            if scalar &gt; 1.0:
                theta=np.arccos(1.0)
            else:
                theta = np.arccos( np.dot(u, v) )#/ (np.sqrt(np.dot(v, v))*np.sqrt(np.dot(u,u))) )

            # We calculate the derivative of the angle to obtain the norm of the angular velocity
            # and apply it to the w vector, taking into account we measure all by
            # double timesteps. Note also that theta= delta theta.
            w[step, i] *= theta/(dt)
        sys.stdout.write(&#34;%3.2f...\r&#34; % (100.*(float(step+1))/(len(n_vecs))))
        sys.stdout.flush()

    # We finally treat the boundary cases
    for i in range(len(n_vecs[0])):
        u, v = n_vecs[-1, i], n_vecs[-2, i]
        w[-1, i] = np.cross(u, v)
        norm = np.sqrt(np.dot(w[-1, i], w[-1, i]))
        if not norm &lt; 1E-7:
            w[-1, i] /= np.sqrt(np.dot(w[-1, i], w[-1, i]))

        scalar = np.dot(u,v)
        if scalar &gt; 1.0:
            theta = np.arccos( 1.0 )# / (np.sqrt(np.dot(v, v))*np.sqrt(np.dot(u, u))) )
        else:
            theta = np.arccos( np.dot(u,v) )

        w[-1, i] *= -theta/(dt)

    np.seterr(**old_err)

    return w</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.angular_velocities_MD_test"><code class="name flex">
<span>def <span class="ident">angular_velocities_MD_test</span></span>(<span>self, n_vecs, dt)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def angular_velocities_MD_test(self, n_vecs, dt):
    # We need error handling in this function
    old_err = np.seterr(all=&#39;raise&#39;)

    w = np.zeros([len(n_vecs), len(n_vecs[0]), 3], dtype=float)
    print(&#34;Processing angular velocities...&#34;)

    for step in range(1, len(n_vecs)-1):
        for i in range(len(n_vecs[0])):
            # u, v = n_vecs[step, i], n_vecs[step+1,i]
            u, v = n_vecs[step, i]-n_vecs[step-1, i], n_vecs[step+1, i]-n_vecs[step,i]

            # We consider here the usual derivative averaging
            # in this new context
            w[step, i] = np.cross(u, v)

            # It needs to be normalized
            # But if it&#39;s zero, it&#39;s zero...
            norm = np.sqrt(np.dot(w[step, i], w[step, i]))
            if not norm &lt; 1E-7:
                w[step, i] /= np.sqrt(np.dot(w[step, i], w[step, i]))

            # Now we compute w. To do this, we compute the angle
            # between the vectors and how it changes, as if
            # we were sitting in a 2D plane.
            
            u, v = n_vecs[step-1, i], n_vecs[step+1,i]

            scalar = np.dot(v,u)
            if scalar &gt; 1.0:
                theta=np.arccos(1.0)
            else:
                theta = np.arccos( np.dot(u, v) )#/ (np.sqrt(np.dot(v, v))*np.sqrt(np.dot(u,u))) )

            # We calculate the derivative of the angle to obtain the norm of the angular velocity
            # and apply it to the w vector, taking into account we measure all by
            # double timesteps. Note also that theta= delta theta.
            w[step, i] *= theta/(2*dt)
        sys.stdout.write(&#34;%3.2f...\r&#34; % (100.*(float(step+1))/(len(n_vecs))))
        sys.stdout.flush()

    &#34;&#34;&#34;
    # We finally treat the boundary cases
    for i in range(len(n_vecs[0])):
        u, v = n_vecs[-1, i], n_vecs[-2, i]
        w[-1, i] = np.cross(u, v)
        norm = np.sqrt(np.dot(w[-1, i], w[-1, i]))
        if not norm &lt; 1E-7:
            w[-1, i] /= np.sqrt(np.dot(w[-1, i], w[-1, i]))

        scalar = np.dot(u,v)
        if scalar &gt; 1.0:
            theta = np.arccos( 1.0 )# / (np.sqrt(np.dot(v, v))*np.sqrt(np.dot(u, u))) )
        else:
            theta = np.arccos( np.dot(u,v) )

        w[-1, i] *= -theta/(dt)
    &#34;&#34;&#34;

    np.seterr(**old_err)

    return w[1:-1]</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.autocorrelate_peratom"><code class="name flex">
<span>def <span class="ident">autocorrelate_peratom</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.autocorrelate_vector"><code class="name flex">
<span>def <span class="ident">autocorrelate_vector</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.autocorrelate_window"><code class="name flex">
<span>def <span class="ident">autocorrelate_window</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.calculate_angle"><code class="name flex">
<span>def <span class="ident">calculate_angle</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.calculate_angle_full"><code class="name flex">
<span>def <span class="ident">calculate_angle_full</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.calculate_angle_full_original"><code class="name flex">
<span>def <span class="ident">calculate_angle_full_original</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.calculate_polarization"><code class="name flex">
<span>def <span class="ident">calculate_polarization</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.calculate_polarization_direction"><code class="name flex">
<span>def <span class="ident">calculate_polarization_direction</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.compute_RACF"><code class="name flex">
<span>def <span class="ident">compute_RACF</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.compute_RACF_serial"><code class="name flex">
<span>def <span class="ident">compute_RACF_serial</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.compute_RACF_test"><code class="name flex">
<span>def <span class="ident">compute_RACF_test</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.compute_VACF"><code class="name flex">
<span>def <span class="ident">compute_VACF</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.compute_VACF_direct"><code class="name flex">
<span>def <span class="ident">compute_VACF_direct</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.compute_VACF_parallel"><code class="name flex">
<span>def <span class="ident">compute_VACF_parallel</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.compute_VACF_serial"><code class="name flex">
<span>def <span class="ident">compute_VACF_serial</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.fit_BM"><code class="name flex">
<span>def <span class="ident">fit_BM</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.fit_func"><code class="name flex">
<span>def <span class="ident">fit_func</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.func_derivative"><code class="name flex">
<span>def <span class="ident">func_derivative</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.func_derivative_direct"><code class="name flex">
<span>def <span class="ident">func_derivative_direct</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.func_integral"><code class="name flex">
<span>def <span class="ident">func_integral</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.func_interpol"><code class="name flex">
<span>def <span class="ident">func_interpol</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.func_spline"><code class="name flex">
<span>def <span class="ident">func_spline</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.process_EV"><code class="name flex">
<span>def <span class="ident">process_EV</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
<dt id="ctoolkit.tools.physicalProperties.physicalProperties.solve_VP"><code class="name flex">
<span>def <span class="ident">solve_VP</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inner1(*args, **kwargs):

    # storing time before function execution
    begin = time.time()

    val = func(*args, **kwargs)

    # storing time after function execution
    end = time.time()
    timer_name = func.__name__
    timer_time = end-begin
    if timer_name in timers_dict:
        timers_dict[timer_name] += timer_time
    else:
        timers_dict[timer_name] = timer_time

    return val</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ctoolkit.tools" href="index.html">ctoolkit.tools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ctoolkit.tools.physicalProperties.physicalProperties" href="#ctoolkit.tools.physicalProperties.physicalProperties">physicalProperties</a></code></h4>
<ul class="">
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.ACF_2D" href="#ctoolkit.tools.physicalProperties.physicalProperties.ACF_2D">ACF_2D</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.BM" href="#ctoolkit.tools.physicalProperties.physicalProperties.BM">BM</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.BMprime" href="#ctoolkit.tools.physicalProperties.physicalProperties.BMprime">BMprime</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.C_from_PDOS" href="#ctoolkit.tools.physicalProperties.physicalProperties.C_from_PDOS">C_from_PDOS</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.EV_range" href="#ctoolkit.tools.physicalProperties.physicalProperties.EV_range">EV_range</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.Fvib_from_PDOS" href="#ctoolkit.tools.physicalProperties.physicalProperties.Fvib_from_PDOS">Fvib_from_PDOS</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.GF" href="#ctoolkit.tools.physicalProperties.physicalProperties.GF">GF</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.G_from_Fvib" href="#ctoolkit.tools.physicalProperties.physicalProperties.G_from_Fvib">G_from_Fvib</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.PDOS_from_ACF" href="#ctoolkit.tools.physicalProperties.physicalProperties.PDOS_from_ACF">PDOS_from_ACF</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.PV_range" href="#ctoolkit.tools.physicalProperties.physicalProperties.PV_range">PV_range</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.S_from_2Dhist" href="#ctoolkit.tools.physicalProperties.physicalProperties.S_from_2Dhist">S_from_2Dhist</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.S_from_PDOS" href="#ctoolkit.tools.physicalProperties.physicalProperties.S_from_PDOS">S_from_PDOS</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.angular_velocities_MD" href="#ctoolkit.tools.physicalProperties.physicalProperties.angular_velocities_MD">angular_velocities_MD</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.angular_velocities_MD_GPT" href="#ctoolkit.tools.physicalProperties.physicalProperties.angular_velocities_MD_GPT">angular_velocities_MD_GPT</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.angular_velocities_MD_deprecated" href="#ctoolkit.tools.physicalProperties.physicalProperties.angular_velocities_MD_deprecated">angular_velocities_MD_deprecated</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.angular_velocities_MD_eig" href="#ctoolkit.tools.physicalProperties.physicalProperties.angular_velocities_MD_eig">angular_velocities_MD_eig</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.angular_velocities_MD_test" href="#ctoolkit.tools.physicalProperties.physicalProperties.angular_velocities_MD_test">angular_velocities_MD_test</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.autocorrelate_peratom" href="#ctoolkit.tools.physicalProperties.physicalProperties.autocorrelate_peratom">autocorrelate_peratom</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.autocorrelate_vector" href="#ctoolkit.tools.physicalProperties.physicalProperties.autocorrelate_vector">autocorrelate_vector</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.autocorrelate_window" href="#ctoolkit.tools.physicalProperties.physicalProperties.autocorrelate_window">autocorrelate_window</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.calculate_angle" href="#ctoolkit.tools.physicalProperties.physicalProperties.calculate_angle">calculate_angle</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.calculate_angle_full" href="#ctoolkit.tools.physicalProperties.physicalProperties.calculate_angle_full">calculate_angle_full</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.calculate_angle_full_original" href="#ctoolkit.tools.physicalProperties.physicalProperties.calculate_angle_full_original">calculate_angle_full_original</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.calculate_polarization" href="#ctoolkit.tools.physicalProperties.physicalProperties.calculate_polarization">calculate_polarization</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.calculate_polarization_direction" href="#ctoolkit.tools.physicalProperties.physicalProperties.calculate_polarization_direction">calculate_polarization_direction</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.compute_RACF" href="#ctoolkit.tools.physicalProperties.physicalProperties.compute_RACF">compute_RACF</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.compute_RACF_serial" href="#ctoolkit.tools.physicalProperties.physicalProperties.compute_RACF_serial">compute_RACF_serial</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.compute_RACF_test" href="#ctoolkit.tools.physicalProperties.physicalProperties.compute_RACF_test">compute_RACF_test</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.compute_VACF" href="#ctoolkit.tools.physicalProperties.physicalProperties.compute_VACF">compute_VACF</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.compute_VACF_direct" href="#ctoolkit.tools.physicalProperties.physicalProperties.compute_VACF_direct">compute_VACF_direct</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.compute_VACF_parallel" href="#ctoolkit.tools.physicalProperties.physicalProperties.compute_VACF_parallel">compute_VACF_parallel</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.compute_VACF_serial" href="#ctoolkit.tools.physicalProperties.physicalProperties.compute_VACF_serial">compute_VACF_serial</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.fit_BM" href="#ctoolkit.tools.physicalProperties.physicalProperties.fit_BM">fit_BM</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.fit_func" href="#ctoolkit.tools.physicalProperties.physicalProperties.fit_func">fit_func</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.func_derivative" href="#ctoolkit.tools.physicalProperties.physicalProperties.func_derivative">func_derivative</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.func_derivative_direct" href="#ctoolkit.tools.physicalProperties.physicalProperties.func_derivative_direct">func_derivative_direct</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.func_integral" href="#ctoolkit.tools.physicalProperties.physicalProperties.func_integral">func_integral</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.func_interpol" href="#ctoolkit.tools.physicalProperties.physicalProperties.func_interpol">func_interpol</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.func_spline" href="#ctoolkit.tools.physicalProperties.physicalProperties.func_spline">func_spline</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.process_EV" href="#ctoolkit.tools.physicalProperties.physicalProperties.process_EV">process_EV</a></code></li>
<li><code><a title="ctoolkit.tools.physicalProperties.physicalProperties.solve_VP" href="#ctoolkit.tools.physicalProperties.physicalProperties.solve_VP">solve_VP</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>